# Flutter Compositions — Full Documentation

> Complete reference for the Flutter Compositions reactive framework.


---

# Introduction

## What is Flutter Compositions?

Flutter Compositions is a reactive framework for Flutter inspired by [Vue's Composition API](https://vuejs.org/guide/extras/composition-api-faq.html). It replaces `StatefulWidget` boilerplate with a declarative, signal-based programming model built on [`alien_signals`](https://pub.dev/packages/alien_signals).

At its core, you write a `setup()` method that runs **once**, declare reactive state with `ref()`, derive values with `computed()`, and return a builder function that automatically re-runs when dependencies change:

```dart
class Counter extends CompositionWidget {
  const Counter({super.key});

  @override
  Widget Function(BuildContext) setup() {
    final count = ref(0);
    final doubled = computed(() => count.value * 2);

    return (context) => Column(
      children: [
        Text('Count: ${count.value}'),
        Text('Doubled: ${doubled.value}'),
        ElevatedButton(
          onPressed: () => count.value++,
          child: const Text('Increment'),
        ),
      ],
    );
  }
}
```

No `State` class. No `setState()`. No manual `dispose()`. Just reactive state and a builder.

## Why Choose Flutter Compositions?

### 1. Fine-Grained Reactivity

Backed by `alien_signals`, reading `.value` registers dependencies automatically. Only the widgets that touch a modified ref rebuild — no unnecessary subtree reconstructions.

### 2. Vue-like Developer Experience

APIs (`ref()`, `computed()`, `watch()`) mirror the Vue Composition API, lowering the learning curve for frontend developers. `setup()` centralizes state initialization, computed values, and lifecycle hooks.

### 3. Lifecycle and Resource Management

| Feature | What it does |
|---------|-------------|
| `onMounted` / `onUnmounted` / `onBuild` | Declarative lifecycle hooks |
| `useScrollController`, `useAnimationController`, … | Auto-dispose controllers |
| Effect cleanup via `effectScope` | No forgotten subscriptions |

### 4. Built-in Type-Safe Dependency Injection

`InjectionKey<T>` powers `provide` / `inject` — pass `Ref<T>` or any object while staying reactive and type-safe. Works out of the box, yet remains compatible with Riverpod, GetIt, and other DI solutions.

### 5. Hot Reload & State Preservation

Each `Ref` keeps a stable position inside `setup()`. As long as the declaration order stays intact, hot reload preserves state. Builders rely on reactive signals, so only affected areas refresh after a reload.

## How Does It Compare?

### vs. `StatefulWidget`

| Aspect | StatefulWidget | Flutter Compositions |
|--------|---------------|---------------------|
| State declaration | Separate `State` class | Inline in `setup()` |
| Rebuilds | `setState()` rebuilds entire subtree | Only refs that changed |
| Prop changes | Manual `didUpdateWidget` | Automatic via `widget()` |
| Controllers | Manual `dispose()` | Auto-disposed `use*` helpers |

See the full [migration guide](./from-stateful-widget.md).

### vs. `flutter_hooks`

| Aspect | Flutter Compositions | flutter_hooks |
|--------|---------------------|---------------|
| Mental model | Vue Composition API | React Hooks |
| Reactivity | Fine-grained signals | Full `build` re-run |
| DI | Built-in `provide`/`inject` | External packages |
| Lifecycle | `onMounted`, `onUnmounted` | `useEffect` callbacks |

### vs. Vue Composition API

| Aspect | Flutter Compositions | Vue |
|--------|---------------------|-----|
| Rendering | Flutter widget tree | Virtual DOM / templates |
| Reactivity engine | `alien_signals` (explicit refs) | Proxy-based (deep by default) |
| Props | `widget()` returns `ComputedRef` | Props are reactive proxies |
| DI keys | `InjectionKey<T>` (compile-time safe) | String/Symbol keys |

## When It Shines

- You want a development model that feels like Vue Composition API.
- Performance matters and you need to avoid unnecessary rebuilds.
- Controllers, subscriptions, or effects must be consistently disposed.
- You value type-safe dependency injection without extra packages.
- The project targets multiple platforms but you want a unified reactive style.

## When to Think Twice

- The app is tiny and `setState` already covers your needs.
- The team is deeply invested in `flutter_hooks`, BLoC, or Redux with heavy custom tooling.
- You prefer external/global state managers to drive the entire app.

## Next Steps

- [Quick Start](./getting-started.md) — install and build your first widget
- [The Composition Widget](./composition-widget.md) — deep dive into `CompositionWidget` and `CompositionBuilder`
- [Reactivity Fundamentals](./reactivity-fundamentals.md) — understand `ref`, `computed`, and reactive collections

---

# Getting Started

Welcome to Flutter Compositions! This guide will walk you through the installation and the creation of your first reactive `CompositionWidget`.

## 1. Installation

First, add `flutter_compositions` to your project's `pubspec.yaml` file.

```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_compositions: ^0.1.0 # Please use the latest version
```

Then, run `flutter pub get` to install the package.

## 2. Create Your First CompositionWidget

A `CompositionWidget` is the core of `flutter_compositions`. It looks like a `StatelessWidget` but features a `setup()` method that runs only once, where you can define your reactive state.

Let's create a simple counter:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_compositions/flutter_compositions.dart';

class CounterWidget extends CompositionWidget {
  const CounterWidget({super.key});

  @override
  Widget Function(BuildContext) setup() {
    // 1. Create a reactive state `count` with an initial value of 0
    final count = ref(0);

    // 2. Create a computed property `doubled` that automatically updates when `count` changes
    final doubled = computed(() => count.value * 2);

    // 3. Return a builder function that rebuilds automatically on reactive state changes
    return (context) => Scaffold(
      appBar: AppBar(title: const Text('Counter Example')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            const Text('You have pushed the button this many times:'),
            Text(
              '${count.value}', // Read the .value directly
              style: Theme.of(context).textTheme.headlineMedium,
            ),
            Text('The doubled value is: ${doubled.value}'),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // 4. Modify the .value to trigger an update
          count.value++;
        },
        child: const Icon(Icons.add),
      ),
    );
  }
}
```

## Core Concepts Explained

1.  **`CompositionWidget`**: A special widget whose `setup` method runs only once during `initState`. This means your state and business logic are initialized only once, not on every rebuild.

2.  **`ref(initialValue)`**: Creates a Reactive Reference. It's a wrapper object, and you need to access and modify its internal value via the `.value` property. When you modify `.value`, everything that depends on it updates automatically.

3.  **`computed(() => ...)`**: Creates a computed property. It derives its value from its reactive dependencies (like `count.value`). When a dependency changes, the computed's value updates, triggering a rebuild of the UI that uses it.

4.  **The `builder` function**: The return value of `setup()` is a `Widget Function(BuildContext)`. This function is like the `build` method of a `StatelessWidget`, but it's wrapped in a reactive `effect`. This means it only re-executes when a reactive state used inside it (like `count.value`) changes, enabling fine-grained UI updates.

## 3. Use Your Widget

You can now use `CounterWidget` just like any other Flutter widget:

```dart
void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: CounterWidget(),
    );
  }
}
```

That's it! You've created a fully functional, reactive widget without ever using a `StatefulWidget` or `setState()`.

In the next chapter, we'll dive deeper into the core concepts of a `Composition`.

---

# The Composition Widget

Flutter Compositions provides three widget types that integrate with the reactive system. This page explains how each works and when to use them.

## CompositionWidget

`CompositionWidget` is the primary building block. It looks like a `StatelessWidget` but features a `setup()` method that runs **once** during the widget's lifetime.

```dart
class UserCard extends CompositionWidget {
  const UserCard({super.key, required this.name});

  final String name;

  @override
  Widget Function(BuildContext) setup() {
    // Runs once — declare state, computed values, watchers, and lifecycle hooks here
    final props = widget();
    final greeting = computed(() => 'Hello, ${props.value.name}!');

    return (context) => Text(greeting.value);
  }
}
```

### The Golden Rule of `setup()`

> `setup()` runs only once in the widget's lifecycle (equivalent to `StatefulWidget`'s `initState`).

This means you can safely initialize state, create controllers, and register listeners here without worrying about them being recreated on every widget rebuild.

The **builder function** returned from `setup()` is different — it re-executes whenever any of its reactive dependencies change.

### Rules for `setup()`

1. **Must be synchronous** — it must return a builder function directly. Use `onMounted()` for async initialization.
2. **Runs only once** — state persists across rebuilds via signals.
3. **No conditional composition APIs** — always call `ref()`, `computed()`, `watch()`, etc. in a consistent order (similar to React Hooks rules).
4. **No `BuildContext` access** — access context only in the returned builder function or in `onBuild` callbacks.

## CompositionBuilder

`CompositionBuilder` brings the same reactive experience to inline/one-off usages without creating a dedicated widget class:

```dart
CompositionBuilder(
  setup: () {
    final count = ref(0);

    return (context) => Scaffold(
      body: Center(child: Text('${count.value}')),
      floatingActionButton: FloatingActionButton(
        onPressed: () => count.value++,
        child: const Icon(Icons.add),
      ),
    );
  },
)
```

Use `CompositionBuilder` when:
- You need reactive state in a one-off location (e.g., a dialog, a test harness)
- You want to provide dependencies to a subtree without a dedicated widget class

## ComputedBuilder

`ComputedBuilder` wraps a section of UI in its own reactive effect. It observes the refs read inside its builder and only rebuilds **that subtree** when one of them changes:

```dart
@override
Widget Function(BuildContext) setup() {
  final count = ref(0);
  final name = ref('Alice');

  return (context) => Column(
    children: [
      // This rebuilds when count OR name changes
      Text('${name.value}: ${count.value}'),

      // This only rebuilds when count changes
      ComputedBuilder(
        builder: (context) => Text('Count only: ${count.value}'),
      ),

      // This never rebuilds (no reactive deps)
      const ExpensiveWidget(),
    ],
  );
}
```

Use `ComputedBuilder` to:
- Isolate hot spots that update frequently from parents that should stay static
- Pair with `computed` values so expensive derivations only re-run when their dependencies change
- Wrap focused fragments of the widget tree for maximum granularity

## How It Works Under the Hood

All three widgets extend `StatelessWidget` with custom `Element` implementations:

| Widget | Element |
|--------|---------|
| `CompositionWidget` | `_CompositionElement extends StatelessElement` |
| `CompositionBuilder` | `_CompositionBuilderElement extends StatelessElement` |
| `ComputedBuilder` | `_ComputedBuilderElement extends StatelessElement` |

This architecture eliminates the need for `State` objects. The custom Elements:

1. **On mount**: create a `SetupContext`, run `setup()`, store the builder, register it as a reactive effect
2. **On dependency change**: the reactive system calls `markNeedsBuild()` directly (no `setState` overhead)
3. **On unmount**: dispose all effects, run `onUnmounted` callbacks, clean up controllers

### Memory and Performance

- **~15-20% less memory** per instance (no `State` object overhead)
- **5-25% lower update latency** (direct `markNeedsBuild()` instead of `setState`)
- **Automatic batching** — multiple ref writes in the same microtask collapse into a single rebuild

## Choosing the Right Widget

| Scenario | Widget |
|----------|--------|
| Reusable component with props | `CompositionWidget` |
| One-off reactive UI (tests, dialogs) | `CompositionBuilder` |
| Isolate a subtree for performance | `ComputedBuilder` |
| Static UI without reactive state | Regular `StatelessWidget` / `const` widgets |

## Next Steps

- [Reactivity Fundamentals](./reactivity-fundamentals.md) — learn `ref`, `computed`, and reactive collections
- [Lifecycle Hooks](./lifecycle-hooks.md) — `onMounted`, `onUnmounted`, `onBuild`
- [Reactive Props](./reactive-props.md) — how to react to prop changes with `widget()`

---

# Reactivity Fundamentals

Understanding Flutter Compositions' reactivity system is key to building efficient, maintainable applications. This guide explains the core reactive primitives and how they work together.

## Overview

Flutter Compositions uses a fine-grained reactivity system powered by [`alien_signals`](https://pub.dev/packages/alien_signals). Unlike Flutter's `setState` which rebuilds entire widget subtrees, this system updates only the specific parts of your UI that depend on changed data.

## The Three Pillars of Reactivity

### 1. Ref - Reactive State

`ref()` creates reactive state that can be read and written. When you modify a ref's value, all computations and UI components that depend on it automatically update.

```dart
// Create a ref
final count = ref(0);

// Read the value
print(count.value); // 0

// Write the value (triggers reactivity)
count.value++;
print(count.value); // 1
```

**Key Points**:
- Always access state through `.value`
- Writes trigger automatic updates
- Refs can hold any type: primitives, objects, lists, etc.

### 2. Computed - Derived State

`computed()` creates values derived from other reactive state. They automatically update when their dependencies change and are cached until dependencies change.

```dart
final count = ref(0);
final doubled = computed(() => count.value * 2);

print(doubled.value); // 0

count.value = 5;
print(doubled.value); // 10
```

**Key Points**:
- Lazy evaluation - only computes when accessed
- Automatic dependency tracking
- Cached results for performance
- Read-only (use `writableComputed` for bidirectional)

### 3. Watch & WatchEffect - Side Effects

`watch()` and `watchEffect()` run side effects when reactive dependencies change. See the dedicated [Watchers & Effects](./watchers-and-effects.md) page for full details.

## Reactivity in Action

### Example: Todo List

```dart
class TodoList extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    // State: list of todos
    final todos = ref(<String>['Buy milk', 'Walk dog']);

    // State: filter
    final filter = ref('all'); // 'all', 'completed', 'active'

    // State: completion status
    final completed = ref(<bool>[false, false]);

    // Computed: filtered todos
    final filteredTodos = computed(() {
      if (filter.value == 'all') {
        return List.generate(
          todos.value.length,
          (i) => todos.value[i],
        );
      } else if (filter.value == 'completed') {
        return [
          for (var i = 0; i < todos.value.length; i++)
            if (completed.value[i]) todos.value[i],
        ];
      } else { // 'active'
        return [
          for (var i = 0; i < todos.value.length; i++)
            if (!completed.value[i]) todos.value[i],
        ];
      }
    });

    // Computed: stats
    final totalCount = computed(() => todos.value.length);
    final completedCount = computed(
      () => completed.value.where((c) => c).length,
    );

    // Side effect: log changes
    watch(
      () => completedCount.value,
      (newCount, oldCount) {
        print('Completed: $oldCount → $newCount');
      },
    );

    // Functions
    void addTodo(String todo) {
      todos.value = [...todos.value, todo];
      completed.value = [...completed.value, false];
    }

    void toggleTodo(int index) {
      final newCompleted = [...completed.value];
      newCompleted[index] = !newCompleted[index];
      completed.value = newCompleted;
    }

    return (context) => Column(
      children: [
        // Add todo input
        TextField(
          onSubmitted: addTodo,
          decoration: InputDecoration(hintText: 'Add todo...'),
        ),

        // Filter buttons
        Row(
          children: [
            for (final f in ['all', 'active', 'completed'])
              ElevatedButton(
                onPressed: () => filter.value = f,
                child: Text(f),
              ),
          ],
        ),

        // Stats
        Text('Total: ${totalCount.value}, Completed: ${completedCount.value}'),

        // Todo list
        for (var i = 0; i < filteredTodos.value.length; i++)
          ListTile(
            title: Text(filteredTodos.value[i]),
            leading: Checkbox(
              value: completed.value[todos.value.indexOf(filteredTodos.value[i])],
              onChanged: (_) => toggleTodo(
                todos.value.indexOf(filteredTodos.value[i]),
              ),
            ),
          ),
      ],
    );
  }
}
```

## Reactive Collections

When working with collections (Lists, Maps, Sets), you must create new instances to trigger reactivity:

```dart
final items = ref(<String>[]);

// ❌ This won't trigger updates
items.value.add('new item');

// ✅ Create a new list
items.value = [...items.value, 'new item'];

// ✅ Or use spread operator
items.value = [...items.value];
```

## Common Patterns

### Pattern 1: Input Binding

```dart
final name = ref('');

return (context) => TextField(
  onChanged: (value) => name.value = value,
  controller: TextEditingController(text: name.value),
);

// Better: use useTextEditingController
final (controller, text, _) = useTextEditingController();
return (context) => TextField(controller: controller);
```

### Pattern 2: Conditional Rendering

```dart
final isLoggedIn = ref(false);

return (context) => isLoggedIn.value
    ? Text('Welcome back!')
    : ElevatedButton(
        onPressed: () => isLoggedIn.value = true,
        child: Text('Login'),
      );
```

### Pattern 3: List Rendering

```dart
final items = ref(['Apple', 'Banana', 'Cherry']);

return (context) => Column(
  children: [
    for (final item in items.value)
      ListTile(title: Text(item)),
  ],
);
```

### Pattern 4: Async Data

```dart
final user = ref<User?>(null);
final loading = ref(false);

onMounted(() async {
  loading.value = true;
  user.value = await fetchUser();
  loading.value = false;
});

return (context) {
  if (loading.value) return CircularProgressIndicator();
  if (user.value == null) return Text('No user');
  return Text('Hello, ${user.value!.name}');
};

// Better: use useFuture or useAsyncData
final userData = useFuture(() => fetchUser());
return (context) => switch (userData.value) {
  AsyncLoading() => CircularProgressIndicator(),
  AsyncData(:final value) => Text('Hello, ${value.name}'),
  _ => Text('No user'),
};
```

## Performance Tips

### 1. Keep Computed Functions Pure

```dart
// ✅ Good - pure function
final greeting = computed(() => 'Hello, ${name.value}');

// ❌ Bad - side effects
final greeting = computed(() {
  print('Computing...'); // Side effect!
  return 'Hello, ${name.value}';
});
```

### 2. Minimize Dependencies in Builder

```dart
// ❌ Rebuilds on any count change
return (context) => Column(
  children: [
    Text('Count: ${count.value}'),
    ExpensiveWidget(), // Rebuilds unnecessarily
  ],
);

// ✅ Extract to separate widget
return (context) => Column(
  children: [
    Text('Count: ${count.value}'),
    const ExpensiveWidget(), // Doesn't rebuild
  ],
);
```

### 3. Use Computed for Expensive Calculations

```dart
// ❌ Calculates on every access
final sum = items.value.fold(0, (a, b) => a + b);

// ✅ Cached until items changes
final sum = computed(() => items.value.fold(0, (a, b) => a + b));
```

## Debugging Reactivity

### Check Dependencies

```dart
// Add logging to see when computed runs
final doubled = computed(() {
  print('Computing doubled');
  return count.value * 2;
});
```

### Watch All Changes

```dart
watchEffect(() {
  print('Count: ${count.value}');
  print('Name: ${name.value}');
  // Prints whenever count OR name changes
});
```

## Common Pitfalls

### Pitfall 1: Forgetting `.value`

```dart
// ❌ Compares Ref objects, not values
if (count == 5) { /* never true */ }

// ✅ Compare values
if (count.value == 5) { /* works */ }
```

### Pitfall 2: Reading Props Directly

```dart
// ❌ Captures initial prop value only
final greeting = computed(() => 'Hello, $name');

// ✅ Reactive to prop changes
final props = widget();
final greeting = computed(() => 'Hello, ${props.value.name}');
```

**Tip: Use Dart's Destructuring Pattern for Props**

When working with multiple props, you can use Dart's destructuring pattern in the builder function to extract props cleanly and ensure reactive access:

```dart
class UserCard extends CompositionWidget {
  final String userId;
  final String displayName;
  final bool isActive;

  const UserCard({
    super.key,
    required this.userId,
    required this.displayName,
    required this.isActive,
  });

  @override
  Widget Function(BuildContext) setup() {
    final props = widget();

    return (context) {
      // Destructure props for cleaner access
      final UserCard(:userId, :displayName, :isActive) = props.value;

      return ListTile(
        title: Text(displayName),
        subtitle: Text('ID: $userId'),
        trailing: Icon(
          isActive ? Icons.check_circle : Icons.cancel,
          color: isActive ? Colors.green : Colors.grey,
        ),
      );
    };
  }
}
```

This pattern ensures that:
- All prop access goes through `props.value`, maintaining reactivity
- Props are clearly declared at the top of the builder function
- The code is more readable when using multiple props

### Pitfall 3: Mutating Collections

```dart
// ❌ Mutation doesn't trigger update
items.value.add('new');

// ✅ Create new collection
items.value = [...items.value, 'new'];
```

## Next Steps

- [Watchers & Effects](./watchers-and-effects.md) — deep dive into `watch` and `watchEffect`
- [Built-in Composables](./built-in-composables.md) — common patterns for controllers and context
- [Async Operations](./async-operations.md) — handling futures and streams
- [Reactivity System](../internals/reactivity-system.md) — how dependency tracking works internally

---

# Watchers & Effects

Watchers let you run side effects when reactive dependencies change. Flutter Compositions provides two APIs: `watch()` for explicit dependency tracking, and `watchEffect()` for automatic tracking.

> **Prefer `computed` over `watch`**: If your goal is to derive a new value from reactive state, use `computed()` instead. `computed` is declarative, automatically cached, and only recalculates when its dependencies change. Reserve `watch`/`watchEffect` for **side effects** — operations that interact with the outside world (logging, navigation, API calls, analytics, local storage, etc.) rather than producing a value.
>
> ```dart
> // ❌ Using watch to derive a value
> final fullName = ref('');
> watch(
>   () => (firstName.value, lastName.value),
>   (names, _) => fullName.value = '${names.$1} ${names.$2}',
> );
>
> // ✅ Using computed to derive a value
> final fullName = computed(() => '${firstName.value} ${lastName.value}');
> ```

## watch()

`watch()` explicitly specifies what to observe and gives you access to both old and new values:

```dart
final count = ref(0);

watch(
  () => count.value,        // Getter: what to watch
  (newValue, oldValue) {    // Callback: what to do
    print('Count changed: $oldValue → $newValue');
  },
);

count.value = 1;  // Prints: "Count changed: 0 → 1"
```

### Watching Multiple Sources

Combine multiple refs in the getter to react when any of them change:

```dart
watch(
  () => (firstName.value, lastName.value),
  (newNames, oldNames) {
    print('Name changed from ${oldNames.$1} ${oldNames.$2} to ${newNames.$1} ${newNames.$2}');
  },
);
```

### Watching Value Transitions

Use the `previous` parameter to compare old and new values:

```dart
watch(() => cart.total.value, (total, previous) {
  if (total > previous) {
    analytics.trackCartChange(total);
  }
});
```

### Watching Props

React to prop changes by watching through `widget()`:

```dart
@override
Widget Function(BuildContext) setup() {
  final props = widget<UserAvatar>();
  watch(() => props.value.userId, (newId, oldId) {
    cache.loadAvatar(newId);
  });
  // ...
}
```

## watchEffect()

`watchEffect()` automatically tracks all reactive dependencies accessed inside its callback:

```dart
final firstName = ref('John');
final lastName = ref('Doe');

watchEffect(() {
  // Automatically tracks both refs
  print('Full name: ${firstName.value} ${lastName.value}');
});

firstName.value = 'Jane';  // Prints: "Full name: Jane Doe"
lastName.value = 'Smith';  // Prints: "Full name: Jane Smith"
```

### Use Cases

- **Logging and debugging**: trace when and why values change
- **Syncing external systems**: push state changes to analytics, local storage, etc.
- **Side effects without old values**: when you don't need to compare previous state

## When to Use Which

| Scenario | Recommended |
|----------|-------------|
| Derive a new value from reactive state | `computed()` |
| Need old and new values for a side effect | `watch()` |
| Simple side effect, no comparison | `watchEffect()` |
| Explicit control over dependencies | `watch()` |
| Track many dependencies automatically | `watchEffect()` |

## Batched Updates

Multiple writes inside the same microtask collapse into a single re-execution:

```dart
void incrementTwice() {
  count.value++;
  count.value++;
  // The watcher fires once with the final value, not twice
}
```

If you need intermediate frames, schedule them explicitly with `Future.microtask` or `SchedulerBinding`.

## Automatic Cleanup

All watchers created during `setup()` are automatically cleaned up when the widget is unmounted. You don't need to manually cancel them — the `effectScope` handles teardown.

## Debugging Tips

- Use `debugPrint` inside `watchEffect` to trace when it re-runs and what values triggered it.
- Keep an eye out for `ref.value = ref.value` patterns — they trigger unnecessary updates.
- When the UI does not update, check that you read `.value` inside the builder or computation.

## Next Steps

- [Lifecycle Hooks](./lifecycle-hooks.md) — `onMounted`, `onUnmounted`, `onBuild`
- [Reactivity Fundamentals](./reactivity-fundamentals.md) — `ref`, `computed`, collections
- [Reactivity System internals](../internals/reactivity-system.md) — how dependency tracking works

---

# Lifecycle Hooks

Flutter Compositions provides declarative lifecycle hooks that let you attach logic to a widget's lifecycle from within `setup()`. All hooks are registered during `setup()` and fire at the appropriate moment.

## Available Hooks

### onMounted

Executes after the widget is mounted on the screen (in the first frame after mount). Ideal for:
- Making network requests
- Initializing resources that need a rendered widget
- Starting animations

```dart
@override
Widget Function(BuildContext) setup() {
  final data = ref<String?>(null);

  onMounted(() async {
    // Safe to do async work here
    data.value = await fetchData();
  });

  return (context) => Text(data.value ?? 'Loading...');
}
```

### onUnmounted

Executes just before the widget is destroyed (during unmount). Use it to:
- Clean up timers, subscriptions, or event listeners
- Cancel ongoing operations
- Release resources not managed by `use*` helpers

```dart
@override
Widget Function(BuildContext) setup() {
  late final Timer timer;

  onMounted(() {
    timer = Timer.periodic(const Duration(seconds: 1), (t) {
      print('Tick ${t.tick}');
    });
  });

  onUnmounted(() {
    timer.cancel();
  });

  return (context) => Container();
}
```

### onBuild

Executes every time the builder function runs. This hook receives the current `BuildContext` and is primarily used internally by composables to access `InheritedWidget` data:

```dart
@override
Widget Function(BuildContext) setup() {
  final width = ref(0.0);

  onBuild((context) {
    width.value = MediaQuery.of(context).size.width;
  });

  return (context) => Text('Width: ${width.value}');
}
```

::: tip
For accessing `InheritedWidget` data reactively, prefer using `useContextRef()` or the built-in composables like `useMediaQuery()`, `useTheme()`, etc. They handle the `onBuild` integration for you.
:::

## Multiple Hooks

You can register multiple instances of the same hook. They execute in registration order:

```dart
@override
Widget Function(BuildContext) setup() {
  onMounted(() => print('First mounted callback'));
  onMounted(() => print('Second mounted callback'));

  onUnmounted(() => print('First cleanup'));
  onUnmounted(() => print('Second cleanup'));

  return (context) => Container();
}
```

## Colocating Setup and Cleanup

A common pattern is to register cleanup inside `onMounted`, keeping setup and teardown close together:

```dart
onMounted(() {
  final subscription = stream.listen((event) {
    handleEvent(event);
  });

  onUnmounted(() {
    subscription.cancel();
  });
});
```

## Lifecycle Mapping from StatefulWidget

| StatefulWidget | Flutter Compositions |
|---------------|---------------------|
| `initState()` | Body of `setup()` |
| `addPostFrameCallback` in `initState` | `onMounted()` |
| `dispose()` | `onUnmounted()` |
| `build()` | Builder function returned from `setup()` |
| `didUpdateWidget()` | Automatic via `widget()` reactive props |
| `didChangeDependencies()` | Automatic via `useContextRef()` / `onBuild()` |

## Automatic Cleanup

Most resources don't need manual cleanup when you use the framework's built-in helpers:

| Resource | Auto-cleaned by |
|----------|----------------|
| `Ref`, `ComputedRef` | `effectScope` disposal |
| `watch`, `watchEffect` | `effectScope` disposal |
| `ScrollController`, `TextEditingController`, etc. | `use*` helpers |
| `AnimationController` | `useAnimationController` |
| Provided values | Widget unmount |

You only need `onUnmounted` for external resources (timers, raw streams, platform channels, etc.) that aren't managed by composables.

## Next Steps

- [Reactive Props](./reactive-props.md) — how `widget()` handles prop changes
- [Built-in Composables](./built-in-composables.md) — auto-managed controllers
- [Migrating from StatefulWidget](./from-stateful-widget.md) — side-by-side lifecycle comparison

---

# Reactive Props

Since `setup()` runs only once, accessing widget properties directly captures their **initial values** only. To react to prop changes from a parent widget, you must use the `widget()` API.

## The Problem

```dart
class UserCard extends CompositionWidget {
  const UserCard({super.key, required this.name});
  final String name;

  @override
  Widget Function(BuildContext) setup() {
    // ❌ WRONG: captures the initial value of `name` — NOT reactive
    final greeting = computed(() => 'Hello, $name!');

    return (context) => Text(greeting.value);
  }
}
```

When the parent rebuilds and passes a new `name`, the `greeting` computed above will **not** update because `name` was read once during `setup()`.

## The Solution: `widget()`

`widget()` returns a reactive `ComputedRef` that always represents the **latest** widget instance. When the parent passes new props, this ref triggers an update:

```dart
class UserCard extends CompositionWidget {
  const UserCard({super.key, required this.name});
  final String name;

  @override
  Widget Function(BuildContext) setup() {
    // ✅ CORRECT: reactive prop access
    final props = widget();
    final greeting = computed(() => 'Hello, ${props.value.name}!');

    return (context) => Text(greeting.value);
  }
}
```

## Watching Prop Changes

You can use `watch()` to run side effects when specific props change:

```dart
@override
Widget Function(BuildContext) setup() {
  final props = widget();

  watch(() => props.value.userId, (newId, oldId) {
    print('User changed from $oldId to $newId');
    cache.loadAvatar(newId);
  });

  return (context) => Text('User: ${props.value.userId}');
}
```

## Props Destructuring Pattern

When working with multiple props, use Dart's destructuring pattern in the builder function for cleaner access:

```dart
class UserCard extends CompositionWidget {
  final String userId;
  final String displayName;
  final bool isActive;

  const UserCard({
    super.key,
    required this.userId,
    required this.displayName,
    required this.isActive,
  });

  @override
  Widget Function(BuildContext) setup() {
    final props = widget();

    return (context) {
      // Destructure props for cleaner access
      final UserCard(:userId, :displayName, :isActive) = props.value;

      return ListTile(
        title: Text(displayName),
        subtitle: Text('ID: $userId'),
        trailing: Icon(
          isActive ? Icons.check_circle : Icons.cancel,
          color: isActive ? Colors.green : Colors.grey,
        ),
      );
    };
  }
}
```

This pattern ensures:
- All prop access goes through `props.value`, maintaining reactivity
- Props are clearly declared at the top of the builder function
- Code is more readable when using multiple props

## How It Works

Under the hood, `widget()` creates a `_widgetSignal` — a reactive signal that the framework updates whenever `didUpdateWidget` fires (i.e., the parent rebuilds with new props). Any `computed` or `watch` that reads `props.value.someField` automatically subscribes to changes.

```
Parent rebuilds with new props
  → didUpdateWidget fires
  → _widgetSignal.call(newWidget)
  → Dependent computed values recompute
  → Builder re-runs if it uses those computed values
  → Flutter diffs and updates the UI
```

## Common Mistakes

### Accessing props directly

```dart
// ❌ Not reactive — captures initial value only
final id = userId;
final greeting = computed(() => 'Hello, user $id!');

// ✅ Reactive
final props = widget();
final greeting = computed(() => 'Hello, user ${props.value.userId}!');
```

### Comparing with StatefulWidget

In `StatefulWidget`, you'd write `didUpdateWidget` manually:

```dart
// StatefulWidget approach
@override
void didUpdateWidget(UserCard oldWidget) {
  super.didUpdateWidget(oldWidget);
  if (widget.userId != oldWidget.userId) {
    _loadUser();
  }
}

// CompositionWidget approach — much simpler
final props = widget();
watch(() => props.value.userId, (newId, _) {
  loadUser(newId);
});
```

## Next Steps

- [Dependency Injection](./dependency-injection.md) — share state without prop drilling
- [Watchers & Effects](./watchers-and-effects.md) — react to any reactive change
- [The Composition Widget](./composition-widget.md) — how `setup()` and builders work

---

# Dependency Injection

Dependency injection (DI) lets you share services, configuration, and state across the widget tree without threading them through constructors.

Flutter Compositions ships a minimal DI story built on two APIs:

- `provide(key, value)` stores a value for descendants.
- `inject(key, { defaultValue })` retrieves it later.

The APIs ride on `InjectionKey<T>` so you get compile-time safety.

## Why Dependency Injection?

Without DI you end up threading services through every constructor:

```dart
// ❌ No DI – props drilling everywhere
class App extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final authService = AuthService();

    return MaterialApp(
      home: HomePage(authService: authService),
    );
  }
}

class HomePage extends StatelessWidget {
  const HomePage({required this.authService, super.key});
  final AuthService authService;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Header(authService: authService),
        ProfileSection(authService: authService),
      ],
    );
  }
}

class Header extends StatelessWidget {
  const Header({required this.authService, super.key});
  final AuthService authService; // Even if Header never touches it

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        UserMenu(authService: authService),
      ],
    );
  }
}

// ✅ With DI – cleaner and easier to maintain
const authServiceKey = InjectionKey<AuthService>('authService');

class App extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final authService = AuthService();
    provide(authServiceKey, authService);

    return (context) => MaterialApp(home: const HomePage());
  }
}

class UserMenu extends CompositionWidget {
  const UserMenu({super.key});

  @override
  Widget Function(BuildContext) setup() {
    final authService = inject(authServiceKey); // Pull only where needed

    return (context) => /* ... */;
  }
}
```

## Defining Keys

Always declare an `InjectionKey<T>` close to the dependency. Keep the symbol descriptive—it becomes part of error messages.

```dart
const authServiceKey = InjectionKey<AuthService>('authService');
const localeKey = InjectionKey<Ref<Locale>>('locale');
```

## Providing Dependencies

Call `provide` inside `setup()`. Provide at the highest level where the dependency is valid, usually an app shell or feature root.

```dart
class AppShell extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final auth = AuthService();
    final locale = ref(const Locale('en'));

    provide(authServiceKey, auth);
    provide(localeKey, locale);

    return (context) => MaterialApp(
          locale: locale.value,
          home: const HomePage(),
        );
  }
}
```

## Injecting Dependencies

Descendants call `inject(key)` inside their own `setup()` methods.

```dart
class ProfileMenu extends CompositionWidget {
  const ProfileMenu({super.key});

  @override
  Widget Function(BuildContext) setup() {
    final auth = inject(authServiceKey);
    final locale = inject(localeKey);

    return (context) => PopupMenuButton(
          itemBuilder: (_) => [
            PopupMenuItem(
              onTap: auth.logout,
              child: const Text('Log out'),
            ),
            PopupMenuItem(
              onTap: () => locale.value = const Locale('zh'),
              child: const Text('Switch language'),
            ),
          ],
        );
  }
}
```

## Optional Dependencies

When a dependency is optional, supply a default:

```dart
const loggerKey = InjectionKey<Logger>('logger');

final logger = inject(
  loggerKey,
  defaultValue: ConsoleLogger(),
);
```

## Scope and Overriding

- Keys respect the widget tree. A closer provider shadows any ancestor.
- This makes feature-level overrides easy (e.g., swapping analytics backends in dev builds).
- Providers are disposed automatically with the widget that created them—no extra wiring.

```dart
class FeatureRoot extends CompositionWidget {
  const FeatureRoot({super.key});

  @override
  Widget Function(BuildContext) setup() {
    provide(analyticsKey, DebugAnalytics());
    return (context) => const FeatureContent();
  }
}
```

## Testing Pattern

Wrap widgets under test in a `CompositionBuilder` and call `provide` before returning the widget tree.

```dart
testWidgets('shows user profile', (tester) async {
  final fakeRepo = FakeUserRepository();
  provide(userRepositoryKey, fakeRepo);

  await tester.pumpWidget(
    CompositionBuilder(
      setup: () {
        provide(userRepositoryKey, fakeRepo);
        return (context) => const MaterialApp(home: ProfilePage());
      },
    ),
  );
});
```

## Common Anti-Patterns

- **Omitting keys.** `provide(someService)` compiles, but you lose type safety and risk conflicts.
- **Providing in deep widgets.** Prefer providing once (e.g., app shell) and injecting anywhere.
- **Relying on globals.** Compose services through DI to keep widgets pure and testable.

## Next Steps

- [Best Practices](./best-practices.md)
- [Async Operations](./async-operations.md)
- [Reactivity Fundamentals](./reactivity-fundamentals.md)

---

# Built-in Composables

`flutter_compositions` provides two categories of composable utilities to help you integrate Flutter objects with the reactive system: **`use*` functions** and **`manage*` functions**.

## Understanding `use*` vs `manage*`

### `use*` Functions - Create and Manage

Functions prefixed with `use` (like `useScrollController`, `useTextEditingController`) **create new instances** and **automatically manage their lifecycle**:

- **Creates**: Returns a new instance of the controller/object
- **Disposes**: Automatically calls `dispose()` when the widget is unmounted
- **Returns**: A reactive `Ref` wrapping the controller

**When to use**: When you need a new controller for your widget.

```dart
// ✅ Use when you need a new controller
final scrollController = useScrollController();
// Automatically disposed on unmount
```

### `manage*` Functions - Integrate Existing

Functions prefixed with `manage` (like `manageValueListenable`, `manageChangeNotifier`) **integrate existing instances** into the reactive system with **automatic lifecycle management**:

- **Requires**: You pass in an existing object
- **Automatic Cleanup**: Always removes listeners on unmount
- **Automatic Disposal** (when applicable):
  - `manageListenable` / `manageValueListenable`: Can't dispose (`Listenable` has no `dispose()`)
  - `manageChangeNotifier`: Automatically calls `dispose()` on unmount
- **Returns**: A reactive `Ref` that syncs with the object

**When to use**: When you have an existing controller/notifier from somewhere else (e.g., inherited from parent, shared state, third-party libraries) that you want to integrate into the reactive system.

```dart
// ✅ Use for Listenable objects (e.g., Animation)
// Automatically removes listener, but can't dispose (Listenable has no dispose method)
final animation = ...; // From AnimationController
final reactiveAnimation = manageListenable(animation);

// ✅ Use for ChangeNotifier objects (e.g., ScrollController)
// Automatically removes listener AND disposes
final controller = ScrollController();
final reactiveController = manageChangeNotifier(controller);
```

## Key Differences

| Feature | `use*` Functions | `manage*` Functions |
|---------|-----------------|---------------------|
| **Creates Instance** | ✅ Yes | ❌ No (you provide it) |
| **Auto Cleanup** | ✅ Always | ✅ Always (removes listeners) |
| **Auto Dispose** | ✅ Always | `manageChangeNotifier`: ✅<br>`manageListenable`: N/A (no dispose method) |
| **Use Case** | New controllers for this widget | Integrate existing objects |
| **Example** | `useScrollController()` | `manageValueListenable(existing)` |

## `useController`

A generic composable for creating any `ChangeNotifier` with hot-reload support and automatic lifecycle management. It combines `hotReloadableContainer` (for preserving state across hot reloads) with `manageChangeNotifier` (for reactive tracking and auto-disposal).

All specific controller composables (`useScrollController`, `usePageController`, `useFocusNode`, `useSearchController`) are built on top of `useController`.

```dart
@override
Widget Function(BuildContext) setup() {
  // Use with any ChangeNotifier subclass
  final controller = useController(() => MyCustomController());

  return (context) => MyWidget(controller: controller.raw); // .raw avoids unnecessary rebuilds
}
```

**Parameters:**
- `create`: A factory function that creates the `ChangeNotifier` instance
- `debugLabel`: Optional label for debugging

**Returns:** A `ReadonlyRef<T>` that tracks changes to the notifier.

## `useScrollController`

```dart
@override
Widget Function(BuildContext) setup() {
  // Create a ScrollController that will be disposed automatically
  final scrollController = useScrollController();

  // Create a computed property to track the scroll offset
  final scrollOffset = computed(() {
    // This will re-compute when the scrollController notifies listeners
    return scrollController.value.offset;
  });

  // Watch for changes in the scroll position
  watch(() => scrollOffset.value, (offset, _) {
    print('Scrolled to: $offset');
  });

  return (context) => ListView.builder(
    controller: scrollController.raw, // .raw avoids unnecessary rebuilds
    itemCount: 100,
    itemBuilder: (context, index) => ListTile(title: Text('Item $index')),
  );
}
```

## `usePageController`

Create an auto-disposed `PageController` and react to page changes without manual bookkeeping.

```dart
@override
Widget Function(BuildContext) setup() {
  final pageController = usePageController(initialPage: 0);
  final currentPage = ref(0);

  watchEffect(() {
    currentPage.value = pageController.value.page?.round() ?? 0;
  });

  return (context) => Column(
    children: [
      Text('Page: ${currentPage.value}'),
      Expanded(
        child: PageView(
          controller: pageController.raw, // .raw avoids unnecessary rebuilds
          children: const [Page1(), Page2(), Page3()],
        ),
      ),
    ],
  );
}
```

## `useFocusNode`

Manage focus state reactively with automatic disposal.

```dart
@override
Widget Function(BuildContext) setup() {
  final focusNode = useFocusNode();
  final hasFocus = ref(false);

  watchEffect(() {
    hasFocus.value = focusNode.value.hasFocus;
  });

  return (context) => Column(
    children: [
      TextField(
        focusNode: focusNode.raw, // .raw avoids unnecessary rebuilds
        decoration: InputDecoration(
          labelText: hasFocus.value ? 'Focused!' : 'Not focused',
        ),
      ),
      ElevatedButton(
        onPressed: () => focusNode.value.requestFocus(),
        child: const Text('Focus'),
      ),
    ],
  );
}
```

## `useTextEditingController`

This is a powerful utility for handling text input. It not only manages the `TextEditingController`'s lifecycle automatically but also provides two-way binding capabilities.

It returns a record: `(controller, text, value)`

- `controller`: The `TextEditingController` instance to pass to a `TextField`.
- `text`: A writable `ComputedRef<String>` that stays in sync with `controller.text`.
- `value`: A writable `ComputedRef<TextEditingValue>` that stays in sync with `controller.value`.

You can programmatically change the input's content by modifying `text.value`, and you can listen to changes in `text.value` to react to user input.

**Example: Two-Way Binding and Live Validation**

```dart
@override
Widget Function(BuildContext) setup() {
  final (usernameController, username, _) = useTextEditingController(text: 'guest');

  // A computed property for the greeting message
  final greeting = computed(() => 'Hello, ${username.value}!');

  // A computed property for simple validation logic
  final isValid = computed(() => username.value.length >= 3);

  return (context) => Column(
    children: [
      Text(greeting.value),
      TextField(
        controller: usernameController,
        decoration: InputDecoration(
          labelText: 'Username',
          errorText: isValid.value ? null : 'Minimum 3 characters required',
        ),
      ),
      ElevatedButton(
        onPressed: () => username.value = 'default', // Programmatically change the text
        child: const Text('Reset'),
      )
    ],
  );
}
```

## `manageValueListenable`

`manageValueListenable` is a bridge for when you need to integrate with existing `ValueNotifier`s or `ValueListenable`s from legacy code or third-party libraries.

It extracts and tracks the value from any `ValueListenable`, returning a tuple of `(listenable, value)`.

**Automatic Management**: This function automatically removes listeners on unmount. It cannot dispose the listenable because the `ValueListenable` interface doesn't have a `dispose()` method. If you're working with a `ChangeNotifier` (which extends both `Listenable` and has `dispose()`), use `manageChangeNotifier` instead.

**Example: Integrating an Existing `ValueNotifier`**

```dart
// Assume you have a ValueNotifier from another part of your app
final legacyCounter = ValueNotifier(0);

@override
Widget Function(BuildContext) setup() {
  // Integrate the existing ValueNotifier into the reactive system
  // Returns (listenable, value) tuple
  final (notifier, count) = manageValueListenable(legacyCounter);

  final doubled = computed(() => count.value * 2);

  return (context) => Column(
    children: [
      Text('Reactive Doubled: ${doubled.value}'),
      // You can also continue to use it with Flutter's native tools
      ValueListenableBuilder<int>(
        valueListenable: notifier,
        builder: (context, value, child) => Text('Legacy Value: $value'),
      ),
    ],
  );
}
```

**Note**:
- The returned value is **read-only**. To modify it, access the original listenable.
- If you're creating a new `ValueNotifier` specifically for this widget, use `ref()` instead.
- If you need to dispose a `ChangeNotifier`, use `manageChangeNotifier()` instead.

## `useContext`

Creates a reactive reference to the `BuildContext`. The context is only available after the first build, not during `setup()`.

**Prefer `useContextRef` for reactive InheritedWidget access.** `useContextRef` provides fine-grained reactivity with equality checks, so it only triggers updates when values actually change. Use `useContext` only when you need the raw `BuildContext` for imperative operations (e.g., `showDialog`, `Navigator.of`, `ScaffoldMessenger.of`).

```dart
@override
Widget Function(BuildContext) setup() {
  final context = useContext();

  onMounted(() {
    // ✅ Use context for imperative operations
    showDialog(
      context: context.value!,
      builder: (context) => const AlertDialog(
        content: Text('Widget mounted!'),
      ),
    );
  });

  return (buildContext) => const SizedBox();
}
```

**Anti-patterns:**
```dart
// ❌ WRONG: Accessing InheritedWidgets through useContext()
final context = useContext();
final theme = computed(() => Theme.of(context.value!));

// ✅ CORRECT: Use useContextRef for reactive InheritedWidget access
final theme = useContextRef(Theme.of);
```

## InheritedWidget Composables

`flutter_compositions` provides a set of composables for accessing Flutter's InheritedWidget data (such as `MediaQuery`, `Theme`, etc.) in a reactive way. These composables automatically track changes and **only trigger updates when values actually change**, significantly improving performance.

### `useContextRef` - Core Function

`useContextRef` is the foundation of all InheritedWidget composables. It converts any value from `BuildContext` into a reactive reference.

**Key Features:**
- ✅ **Performance Optimization**: Uses equality comparison to only trigger updates when values actually change
- ✅ **Custom Comparison**: Supports custom `equals` function for fine-grained control
- ✅ **Type Safe**: Full generic type support

```dart
@override
Widget Function(BuildContext) setup() {
  // Track screen width using default identical comparison
  final width = useContextRef<double>(
    (context) => MediaQuery.of(context).size.width,
  );

  // Track theme brightness with custom equality comparison
  final brightness = useContextRef<Brightness>(
    (context) => Theme.of(context).brightness,
    equals: (a, b) => a == b, // Value equality, not identity
  );

  final message = computed(() =>
    'Width: ${width.value}, Mode: ${brightness.value == Brightness.dark ? "Dark" : "Light"}'
  );

  return (context) => Text(message.value);
}
```

**Important:** `useContextRef` only triggers reactive updates when the equality comparison returns false. This means even if the InheritedWidget rebuilds, your component won't recompute if the value stays the same.

### `useMediaQuery`

Provides reactive access to the full `MediaQueryData`. Automatically updates when device orientation, size, or other properties change.

```dart
@override
Widget Function(BuildContext) setup() {
  final mediaQuery = useMediaQuery();

  final isPortrait = computed(() =>
    mediaQuery.value.orientation == Orientation.portrait
  );

  final screenWidth = computed(() => mediaQuery.value.size.width);

  final pixelRatio = computed(() => mediaQuery.value.devicePixelRatio);

  return (context) => Column(
    children: [
      Text('Width: ${screenWidth.value.toStringAsFixed(0)}'),
      Text('Orientation: ${isPortrait.value ? "Portrait" : "Landscape"}'),
      Text('Pixel ratio: ${pixelRatio.value}'),
    ],
  );
}
```

### `useMediaQueryInfo`

Separates `size` and `orientation` into independent reactive references for more fine-grained reactivity control.

**Why use this?** When you only need size or orientation, this avoids unnecessary recomputations.

```dart
@override
Widget Function(BuildContext) setup() {
  final (size, orientation) = useMediaQueryInfo();

  // Only recomputes when size changes
  final isSmallScreen = computed(() => size.value.width < 600);

  // Only recomputes when orientation changes
  final isPortrait = computed(() => orientation.value == Orientation.portrait);

  final columns = computed(() {
    if (isSmallScreen.value) return 1;
    return isPortrait.value ? 2 : 3;
  });

  return (context) => Text('Columns: ${columns.value}');
}
```

**Performance Benefit:** If only the screen size changes (no rotation), the `orientation` ref won't trigger updates, and computed properties depending on it won't re-execute.

### `useTheme`

Reactive access to current theme data. Automatically updates when the app theme changes.

```dart
@override
Widget Function(BuildContext) setup() {
  final theme = useTheme();

  final primaryColor = computed(() => theme.value.primaryColor);

  final isDark = computed(() => theme.value.brightness == Brightness.dark);

  final textStyle = computed(() => TextStyle(
    color: isDark.value ? Colors.white : Colors.black,
    fontSize: 16,
  ));

  return (context) => Container(
    color: primaryColor.value,
    child: Text(
      'Theme: ${isDark.value ? "Dark" : "Light"}',
      style: textStyle.value,
    ),
  );
}
```

### `usePlatformBrightness`

Tracks system brightness setting (light/dark mode). Automatically updates when the user switches system theme.

```dart
@override
Widget Function(BuildContext) setup() {
  final brightness = usePlatformBrightness();

  final isDark = computed(() => brightness.value == Brightness.dark);

  final statusMessage = computed(() =>
    'System theme: ${isDark.value ? "Dark mode" : "Light mode"}'
  );

  return (context) => Text(statusMessage.value);
}
```

### `useTextScale`

Tracks system text scale factor. Automatically updates when users change text size in system settings.

```dart
@override
Widget Function(BuildContext) setup() {
  final textScale = useTextScale();

  final fontSize = computed(() => 16.0 * textScale.value.scale(1.0));

  final scaleLabel = computed(() {
    final scale = textScale.value.scale(1.0);
    if (scale < 1.0) return 'Small';
    if (scale > 1.5) return 'Large';
    return 'Standard';
  });

  return (context) => Text(
    'Font size: ${scaleLabel.value}',
    style: TextStyle(fontSize: fontSize.value),
  );
}
```

### `useLocale`

Tracks current locale. Automatically updates when system language changes.

```dart
@override
Widget Function(BuildContext) setup() {
  final locale = useLocale();

  final languageCode = computed(() => locale.value.languageCode);

  final greeting = computed(() {
    switch (languageCode.value) {
      case 'zh': return '你好';
      case 'ja': return 'こんにちは';
      case 'es': return 'Hola';
      default: return 'Hello';
    }
  });

  return (context) => Text('${greeting.value} (${languageCode.value})');
}
```

### Responsive Design Example

Combine multiple InheritedWidget composables to create responsive layouts:

```dart
@override
Widget Function(BuildContext) setup() {
  final (size, orientation) = useMediaQueryInfo();
  final theme = useTheme();

  // Calculate breakpoints based on screen size
  final breakpoint = computed(() {
    final width = size.value.width;
    if (width < 600) return 'small';
    if (width < 900) return 'medium';
    return 'large';
  });

  // Calculate columns based on breakpoint and orientation
  final columns = computed(() {
    if (breakpoint.value == 'small') return 1;
    if (breakpoint.value == 'medium') {
      return orientation.value == Orientation.portrait ? 2 : 3;
    }
    return 4;
  });

  // Calculate font size based on breakpoint
  final fontSize = computed(() {
    switch (breakpoint.value) {
      case 'small': return 14.0;
      case 'medium': return 16.0;
      default: return 18.0;
    }
  });

  return (context) => Container(
    color: theme.value.scaffoldBackgroundColor,
    child: GridView.count(
      crossAxisCount: columns.value,
      children: List.generate(
        12,
        (i) => Card(
          child: Center(
            child: Text(
              'Item ${i + 1}',
              style: TextStyle(fontSize: fontSize.value),
            ),
          ),
        ),
      ),
    ),
  );
}
```

### Performance Best Practices

1. **Use specific composables**: Prefer `useMediaQueryInfo()` over `useMediaQuery()` if you only need size or orientation.

2. **Custom equality**: For complex objects, use custom `equals` functions to avoid unnecessary updates:

```dart
final customData = useContextRef<MyData>(
  (context) => MyInheritedWidget.of(context).data,
  equals: (a, b) => a.id == b.id, // Only update when ID changes
);
```

3. **Fine-grained computed**: Break computed properties into smaller parts to minimize recomputation:

```dart
// ✅ Good - Independent computed
final width = computed(() => size.value.width);
final height = computed(() => size.value.height);

// ❌ Worse - One large computed
final dimensions = computed(() => '${size.value.width}x${size.value.height}');
```

---

# Async Operations

Flutter apps regularly talk to the network, disk, and other asynchronous sources. This guide shows how to keep those flows reactive when you build with Flutter Compositions.

## Goals

- Keep loading/error/data state co-located with the widget that needs it.
- Share asynchronous state with descendants without prop drilling.
- Make retries and refresh flows explicit.

## Choosing the Right Composable

| Use case | Recommended tool | Notes |
|----------|-----------------|-------|
| One-off future with simple UI | `useFuture` | Returns a `Ref<AsyncValue<T>>` that you can `switch` on. |
| Future that depends on other reactive values | `useAsyncData` | Automatically re-runs when the `watch` input changes. |
| Stream subscriptions | `useStream` | Keeps the latest event in a `Ref<T?>`. |
| Exposing loading/error/data separately | `useAsyncValue` | Splits an `AsyncValue<T>` into individual refs. |
| Imperative refresh button | `useAsyncData` | The returned `refresh()` callback can be exposed to the UI. |

## Example: Loading a Profile

```dart
class ProfilePage extends CompositionWidget {
  const ProfilePage({super.key, required this.userId});

  final String userId;

  @override
  Widget Function(BuildContext) setup() {
    final props = widget();

    final (status, refresh) = useAsyncData<User, String>(
      (id) => api.fetchUser(id),
      watch: () => props.value.userId,
    );

    return (context) => switch (status.value) {
          AsyncLoading() => const Center(child: CircularProgressIndicator()),
          AsyncError(:final errorValue) => ErrorView(
              message: '$errorValue',
              onRetry: refresh,
            ),
          AsyncData(:final value) => ProfileView(user: value),
          AsyncIdle() => const SizedBox.shrink(),
        };
  }
}
```

Key points:

- `useAsyncData` recalculates when `props.value.userId` changes.
- The `refresh` callback can be wired to pull-to-refresh or a retry button.
- Returning early for `AsyncIdle` covers the first frame before the request starts.

## Example: Streaming Updates

```dart
class NotificationsPanel extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final notifications = useStream<NotificationEvent>(
      notificationBus.events,
      initialData: null,
    );

    final recent = computed(() {
      final event = notifications.value;
      if (event == null) return <NotificationEvent>[];
      return [...previousEvents.value, event]
          .take(10)
          .toList(growable: false);
    });

    return (context) => NotificationList(events: recent.value);
  }
}
```

- `useStream` disposes the subscription automatically.
- Combine the latest emission with other refs (`previousEvents` here) to build derived state.

## Sharing Async State with Descendants

```dart
const todosKey = InjectionKey<ReadonlyRef<AsyncValue<List<Todo>>>>('todos');

class TodosProvider extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (todos, refresh) = useAsyncData<List<Todo>, void>(
      (_) => api.fetchTodos(),
    );

    provide(todosKey, todos);

    return (context) => Column(
          children: [
            ElevatedButton(onPressed: refresh, child: const Text('Refresh')),
            const TodosList(),
          ],
        );
  }
}

class TodosList extends CompositionWidget {
  const TodosList({super.key});

  @override
  Widget Function(BuildContext) setup() {
    final todos = inject(todosKey);

    return (context) => switch (todos.value) {
          AsyncLoading() => const CircularProgressIndicator(),
          AsyncError(:final errorValue) => Text('Error: $errorValue'),
          AsyncData(:final value) => ListView(
              children: [for (final todo in value) TodoTile(todo: todo)],
            ),
          _ => const SizedBox.shrink(),
        };
  }
}
```

- Provide the entire `Ref<AsyncValue<T>>` to descendants to keep reactivity.
- Consumers stay lightweight—they just switch on the async state.

## Handling Parallel Requests

When you need to run multiple futures simultaneously, use `Future.wait` inside `useAsyncData`:

```dart
final (status, _) = useAsyncData<_DashboardPayload, void>(
  (_) async {
    final [user, stats, notifications] = await Future.wait([
      api.fetchUser(),
      api.fetchStats(),
      api.fetchNotifications(),
    ]);
    return _DashboardPayload(user, stats, notifications);
  },
);
```

Wrap heavy requests with caching (e.g., keep the last result in a `Ref` and early-return) to avoid unnecessary network calls during rebuilds.

## Testing Tips

- Pass in fake services through `InjectionKey`s so that composables stay deterministic.
- Pump frames with `tester.pump()` until the async request completes.
- For `useStream`, emit test events through a `StreamController` that you control inside the test.

## Next Steps

- [Dependency Injection](./dependency-injection.md) — keep async code modular
- [Best Practices](./best-practices.md) — larger end-to-end examples

---

# Animations

Animations bring your application to life. This guide explores how to create smooth animations using Flutter Compositions, including basic animations, staggered animations, reactive animation control, and animation patterns.

## Why Use Composables for Animations?

In traditional Flutter, animation controllers require manual lifecycle management:

```dart
// ❌ Traditional approach - lots of boilerplate
class _MyWidgetState extends State<MyWidget>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: Duration(seconds: 1),
    );
  }

  @override
  void dispose() {
    _controller.dispose(); // Don't forget!
    super.dispose();
  }
}

// ✅ Compositions approach - concise and safe
@override
Widget Function(BuildContext) setup() {
  final (controller, animValue) = useAnimationController(
    duration: Duration(seconds: 1),
  );
  // Automatically disposed!

  return (context) => /* ... */;
}
```

## useAnimationController - Basic Animations

`useAnimationController` creates an `AnimationController` with automatic disposal and reactive value tracking.

### Simple Fade In

```dart
class FadeInWidget extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, animValue) = useAnimationController(
      duration: Duration(milliseconds: 500),
    );

    onMounted(() {
      controller.forward();
    });

    return (context) => FadeTransition(
      opacity: controller,
      child: Text('Hello, World!'),
    );
  }
}
```

### Using Reactive Values

```dart
class PulsingHeart extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, animValue) = useAnimationController(
      duration: Duration(milliseconds: 800),
    );

    onMounted(() {
      controller.repeat(reverse: true);
    });

    return (context) => Transform.scale(
      scale: 1.0 + (animValue.value * 0.2), // 1.0 to 1.2
      child: Icon(Icons.favorite, size: 100, color: Colors.red),
    );
  }
}
```

### Rotation Animation

```dart
class SpinningIcon extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, animValue) = useAnimationController(
      duration: Duration(seconds: 2),
    );

    onMounted(() {
      controller.repeat();
    });

    return (context) => Transform.rotate(
      angle: animValue.value * 2 * pi,
      child: Icon(Icons.refresh, size: 48),
    );
  }
}
```

## Interpolated Animations

Use `Tween` to interpolate between values.

### Size Animation

```dart
class GrowingBox extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, _) = useAnimationController(
      duration: Duration(milliseconds: 600),
    );

    final sizeAnimation = manageAnimation(
      parent: controller,
      tween: Tween<double>(begin: 50, end: 200),
    );

    void toggle() {
      if (controller.status == AnimationStatus.completed) {
        controller.reverse();
      } else {
        controller.forward();
      }
    }

    return (context) => GestureDetector(
      onTap: toggle,
      child: AnimatedBuilder(
        animation: sizeAnimation,
        builder: (context, child) => Container(
          width: sizeAnimation.value,
          height: sizeAnimation.value,
          color: Colors.blue,
        ),
      ),
    );
  }
}
```

### Color Animation

```dart
class ColorChangingBox extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, _) = useAnimationController(
      duration: Duration(seconds: 2),
    );

    final colorAnimation = manageAnimation(
      parent: controller,
      tween: ColorTween(
        begin: Colors.blue,
        end: Colors.purple,
      ),
    );

    onMounted(() => controller.repeat(reverse: true));

    return (context) => AnimatedBuilder(
      animation: colorAnimation,
      builder: (context, child) => Container(
        width: 200,
        height: 200,
        color: colorAnimation.value,
      ),
    );
  }
}
```

### Multiple Animations

Animate multiple properties simultaneously:

```dart
class AnimatedCard extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, _) = useAnimationController(
      duration: Duration(milliseconds: 800),
    );

    final sizeAnimation = manageAnimation(
      parent: controller,
      tween: Tween<double>(begin: 100, end: 200),
    );

    final colorAnimation = manageAnimation(
      parent: controller,
      tween: ColorTween(begin: Colors.blue, end: Colors.purple),
    );

    final borderRadiusAnimation = manageAnimation(
      parent: controller,
      tween: Tween<double>(begin: 0, end: 50),
    );

    final rotationAnimation = manageAnimation(
      parent: controller,
      tween: Tween<double>(begin: 0, end: 0.1),
    );

    void toggle() {
      if (controller.isCompleted) {
        controller.reverse();
      } else {
        controller.forward();
      }
    }

    return (context) => GestureDetector(
      onTap: toggle,
      child: AnimatedBuilder(
        animation: controller,
        builder: (context, child) => Transform.rotate(
          angle: rotationAnimation.value,
          child: Container(
            width: sizeAnimation.value,
            height: sizeAnimation.value,
            decoration: BoxDecoration(
              color: colorAnimation.value,
              borderRadius: BorderRadius.circular(
                borderRadiusAnimation.value,
              ),
            ),
          ),
        ),
      ),
    );
  }
}
```

## Curved Animations

Use easing curves to make animations more natural.

### Using Built-in Curves

```dart
class BouncingBox extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, _) = useAnimationController(
      duration: Duration(milliseconds: 1000),
    );

    final curvedAnimation = CurvedAnimation(
      parent: controller,
      curve: Curves.elasticOut, // Elastic easing
    );

    final scaleAnimation = manageAnimation(
      parent: curvedAnimation,
      tween: Tween<double>(begin: 0, end: 1),
    );

    onMounted(() => controller.forward());

    return (context) => AnimatedBuilder(
      animation: scaleAnimation,
      builder: (context, child) => Transform.scale(
        scale: scaleAnimation.value,
        child: Container(
          width: 100,
          height: 100,
          color: Colors.blue,
        ),
      ),
    );
  }
}
```

### Different Curves for Different Phases

```dart
class ComplexCurveBox extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, _) = useAnimationController(
      duration: Duration(seconds: 2),
    );

    final curvedAnimation = CurvedAnimation(
      parent: controller,
      curve: Curves.easeInOut,
      reverseCurve: Curves.bounceOut, // Use different curve when reversing
    );

    final positionAnimation = manageAnimation(
      parent: curvedAnimation,
      tween: Tween<Offset>(
        begin: Offset.zero,
        end: Offset(1, 0),
      ),
    );

    onMounted(() => controller.repeat(reverse: true));

    return (context) => SlideTransition(
      position: positionAnimation,
      child: Container(
        width: 100,
        height: 100,
        color: Colors.blue,
      ),
    );
  }
}
```

## Staggered Animations

Create complex sequenced animations.

### Sequential Transitions

```dart
class StaggeredAnimation extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, _) = useAnimationController(
      duration: Duration(milliseconds: 2000),
    );

    // 0.0 - 0.3: Fade in
    final fadeAnimation = manageAnimation(
      parent: controller,
      tween: Tween<double>(begin: 0, end: 1),
    );

    // 0.2 - 0.6: Slide
    final slideAnimation = manageAnimation(
      parent: CurvedAnimation(
        parent: controller,
        curve: Interval(0.2, 0.6, curve: Curves.easeOut),
      ),
      tween: Tween<Offset>(
        begin: Offset(0, 0.5),
        end: Offset.zero,
      ),
    );

    // 0.5 - 1.0: Scale
    final scaleAnimation = manageAnimation(
      parent: CurvedAnimation(
        parent: controller,
        curve: Interval(0.5, 1.0, curve: Curves.elasticOut),
      ),
      tween: Tween<double>(begin: 0.5, end: 1.0),
    );

    onMounted(() => controller.forward());

    return (context) => AnimatedBuilder(
      animation: controller,
      builder: (context, child) => FadeTransition(
        opacity: fadeAnimation,
        child: SlideTransition(
          position: slideAnimation,
          child: Transform.scale(
            scale: scaleAnimation.value,
            child: Container(
              width: 200,
              height: 200,
              color: Colors.blue,
              child: Center(
                child: Text(
                  'Hello!',
                  style: TextStyle(color: Colors.white, fontSize: 24),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
```

### Staggered List Items

```dart
class StaggeredListAnimation extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final items = ['Apple', 'Banana', 'Cherry', 'Date', 'Elderberry'];

    final (controller, _) = useAnimationController(
      duration: Duration(milliseconds: 1200),
    );

    onMounted(() => controller.forward());

    return (context) => ListView.builder(
      itemCount: items.length,
      itemBuilder: (context, index) {
        // Each item has a slight delay
        final start = index * 0.1;
        final end = start + 0.4;

        final animation = CurvedAnimation(
          parent: controller,
          curve: Interval(start, end, curve: Curves.easeOut),
        );

        return SlideTransition(
          position: Tween<Offset>(
            begin: Offset(1, 0),
            end: Offset.zero,
          ).animate(animation),
          child: FadeTransition(
            opacity: animation,
            child: ListTile(title: Text(items[index])),
          ),
        );
      },
    );
  }
}
```

## Reactive Animation Control

Control animations using reactive state.

### Toggle Animation

```dart
class ExpandableCard extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final isExpanded = ref(false);

    final (controller, _) = useAnimationController(
      duration: Duration(milliseconds: 300),
    );

    final heightAnimation = manageAnimation(
      parent: controller,
      tween: Tween<double>(begin: 100, end: 300),
    );

    // Watch state changes and control animation
    watch(
      () => isExpanded.value,
      (expanded, _) {
        if (expanded) {
          controller.forward();
        } else {
          controller.reverse();
        }
      },
    );

    return (context) => Column(
      children: [
        ElevatedButton(
          onPressed: () => isExpanded.value = !isExpanded.value,
          child: Text(isExpanded.value ? 'Collapse' : 'Expand'),
        ),
        AnimatedBuilder(
          animation: heightAnimation,
          builder: (context, child) => Container(
            width: 300,
            height: heightAnimation.value,
            color: Colors.blue,
            child: Center(
              child: Text(
                'Expandable Content',
                style: TextStyle(color: Colors.white),
              ),
            ),
          ),
        ),
      ],
    );
  }
}
```

### Condition-Based Animation

```dart
class ConditionalAnimation extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final status = ref<Status>(Status.idle);

    final (controller, _) = useAnimationController(
      duration: Duration(milliseconds: 500),
    );

    final colorAnimation = manageAnimation(
      parent: controller,
      tween: ColorTween(begin: Colors.grey, end: Colors.green),
    );

    watch(
      () => status.value,
      (newStatus, _) {
        switch (newStatus) {
          case Status.loading:
            controller.repeat();
          case Status.success:
            controller.forward();
          case Status.error:
            controller.reverse();
          case Status.idle:
            controller.reset();
        }
      },
    );

    return (context) => AnimatedBuilder(
      animation: colorAnimation,
      builder: (context, child) => Container(
        width: 100,
        height: 100,
        color: colorAnimation.value,
      ),
    );
  }
}

enum Status { idle, loading, success, error }
```

### Data-Driven Animation

```dart
class DataDrivenChart extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final value = ref(0.0);
    final targetValue = ref(75.0);

    final (controller, _) = useAnimationController(
      duration: Duration(milliseconds: 800),
    );

    final valueAnimation = manageAnimation(
      parent: CurvedAnimation(
        parent: controller,
        curve: Curves.easeInOut,
      ),
      tween: Tween<double>(begin: 0, end: 100),
    );

    // Watch target value changes
    watch(
      () => targetValue.value,
      (target, _) {
        valueAnimation.tween = Tween<double>(
          begin: value.value,
          end: target,
        );
        controller.forward(from: 0);
      },
    );

    // Update current value
    watchEffect(() {
      value.value = valueAnimation.value;
    });

    return (context) => Column(
      children: [
        // Progress bar
        AnimatedBuilder(
          animation: valueAnimation,
          builder: (context, child) => LinearProgressIndicator(
            value: valueAnimation.value / 100,
          ),
        ),

        // Current value
        Text('${value.value.toStringAsFixed(1)}%'),

        // Controls
        Slider(
          value: targetValue.value,
          min: 0,
          max: 100,
          onChanged: (v) => targetValue.value = v,
        ),
      ],
    );
  }
}
```

## Real-World Examples

### Loading Indicator

```dart
class CustomLoader extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, animValue) = useAnimationController(
      duration: Duration(milliseconds: 1500),
    );

    onMounted(() => controller.repeat());

    final dots = [0, 1, 2];

    return (context) => Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: dots.map((index) {
        // Each dot has a different delay
        final delay = index * 0.2;
        final scale = sin((animValue.value + delay) * 2 * pi) * 0.5 + 1;

        return Transform.scale(
          scale: scale,
          child: Container(
            width: 10,
            height: 10,
            margin: EdgeInsets.symmetric(horizontal: 4),
            decoration: BoxDecoration(
              color: Colors.blue,
              shape: BoxShape.circle,
            ),
          ),
        );
      }).toList(),
    );
  }
}
```

### Swipe to Dismiss

```dart
class SwipeToDismiss extends CompositionWidget {
  const SwipeToDismiss({required this.child, required this.onDismissed});
  final Widget child;
  final VoidCallback onDismissed;

  @override
  Widget Function(BuildContext) setup() {
    final offset = ref(Offset.zero);
    final isDragging = ref(false);

    final (controller, _) = useAnimationController(
      duration: Duration(milliseconds: 200),
    );

    final slideAnimation = manageAnimation(
      parent: controller,
      tween: Tween<Offset>(begin: Offset.zero, end: Offset(-1, 0)),
    );

    void onPanStart(DragStartDetails details) {
      isDragging.value = true;
      controller.stop();
    }

    void onPanUpdate(DragUpdateDetails details) {
      offset.value = Offset(
        (offset.value.dx + details.delta.dx).clamp(-300, 0),
        0,
      );
    }

    void onPanEnd(DragEndDetails details) {
      isDragging.value = false;

      if (offset.value.dx < -100) {
        // Swipe distance is sufficient, dismiss
        controller.forward().then((_) => onDismissed());
      } else {
        // Snap back
        offset.value = Offset.zero;
      }
    }

    final props = widget();

    return (context) => GestureDetector(
      onPanStart: onPanStart,
      onPanUpdate: onPanUpdate,
      onPanEnd: onPanEnd,
      child: AnimatedBuilder(
        animation: controller,
        builder: (context, child) {
          final currentOffset = isDragging.value
              ? offset.value
              : slideAnimation.value;

          return Transform.translate(
            offset: currentOffset,
            child: props.value.child,
          );
        },
      ),
    );
  }
}
```

### Pull to Refresh

```dart
class PullToRefresh extends CompositionWidget {
  const PullToRefresh({required this.onRefresh, required this.child});
  final Future<void> Function() onRefresh;
  final Widget child;

  @override
  Widget Function(BuildContext) setup() {
    final scrollController = useScrollController();
    final pullDistance = ref(0.0);
    final isRefreshing = ref(false);

    final (controller, animValue) = useAnimationController(
      duration: Duration(milliseconds: 500),
    );

    final rotationAnimation = manageAnimation(
      parent: controller,
      tween: Tween<double>(begin: 0, end: 2 * pi),
    );

    void checkRefresh() {
      if (pullDistance.value > 80 && !isRefreshing.value) {
        isRefreshing.value = true;
        controller.repeat();

        onRefresh().then((_) {
          isRefreshing.value = false;
          controller.stop();
          pullDistance.value = 0;
        });
      }
    }

    final props = widget();

    return (context) => NotificationListener<ScrollNotification>(
      onNotification: (notification) {
        if (notification is ScrollUpdateNotification) {
          if (scrollController.value.position.pixels < 0) {
            pullDistance.value = -scrollController.value.position.pixels;
          }
        } else if (notification is ScrollEndNotification) {
          checkRefresh();
        }
        return false;
      },
      child: Stack(
        children: [
          ListView(
            controller: scrollController.raw, // .raw avoids unnecessary rebuilds
            children: [props.value.child],
          ),
          if (pullDistance.value > 0)
            Positioned(
              top: pullDistance.value - 40,
              left: 0,
              right: 0,
              child: Center(
                child: AnimatedBuilder(
                  animation: rotationAnimation,
                  builder: (context, child) => Transform.rotate(
                    angle: isRefreshing.value
                        ? rotationAnimation.value
                        : pullDistance.value / 80 * pi,
                    child: Icon(Icons.refresh, size: 32),
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }
}
```

### Parallax Scrolling

```dart
class ParallaxScroll extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final scrollController = useScrollController();
    final scrollOffset = ref(0.0);

    watchEffect(() {
      scrollOffset.value = scrollController.value.offset;
    });

    return (context) => CustomScrollView(
      controller: scrollController.raw, // .raw avoids unnecessary rebuilds
      slivers: [
        SliverAppBar(
          expandedHeight: 300,
          flexibleSpace: FlexibleSpaceBar(
            background: Transform.translate(
              offset: Offset(0, scrollOffset.value * 0.5), // Parallax effect
              child: Image.network(
                'https://example.com/image.jpg',
                fit: BoxFit.cover,
              ),
            ),
          ),
        ),
        SliverList(
          delegate: SliverChildBuilderDelegate(
            (context, index) => ListTile(title: Text('Item $index')),
            childCount: 50,
          ),
        ),
      ],
    );
  }
}
```

## Animation Composition

Create reusable animation composables.

```dart
// Reusable fade-in animation composable
(AnimationController, Animation<double>) useFadeIn({
  Duration duration = const Duration(milliseconds: 300),
  bool autoStart = true,
}) {
  final (controller, _) = useAnimationController(duration: duration);

  final fadeAnimation = manageAnimation(
    parent: controller,
    tween: Tween<double>(begin: 0, end: 1),
  );

  if (autoStart) {
    onMounted(() => controller.forward());
  }

  return (controller, fadeAnimation);
}

// Usage
class MyWidget extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, fadeAnimation) = useFadeIn();

    return (context) => FadeTransition(
      opacity: fadeAnimation,
      child: Text('Fading in!'),
    );
  }
}
```

## Performance Considerations

### 1. Use const Widgets

```dart
// ✅ Good - const widget won't rebuild
return AnimatedBuilder(
  animation: animation,
  builder: (context, child) => Transform.scale(
    scale: animation.value,
    child: child,
  ),
  child: const ExpensiveWidget(), // const!
);
```

### 2. Limit AnimatedBuilder Scope

```dart
// ❌ Bad - entire tree rebuilds
return AnimatedBuilder(
  animation: controller,
  builder: (context, child) => Column(
    children: [
      Transform.scale(scale: controller.value, child: Icon(Icons.star)),
      ExpensiveWidget(),
      AnotherExpensiveWidget(),
    ],
  ),
);

// ✅ Good - only animated part rebuilds
return Column(
  children: [
    AnimatedBuilder(
      animation: controller,
      builder: (context, child) => Transform.scale(
        scale: controller.value,
        child: Icon(Icons.star),
      ),
    ),
    const ExpensiveWidget(),
    const AnotherExpensiveWidget(),
  ],
);
```

### 3. Reuse Animations

```dart
// ✅ Good - single controller, multiple animations
final (controller, _) = useAnimationController(
  duration: Duration(seconds: 1),
);

final scaleAnimation = manageAnimation(
  parent: controller,
  tween: Tween<double>(begin: 0.5, end: 1.0),
);

final rotationAnimation = manageAnimation(
  parent: controller,
  tween: Tween<double>(begin: 0, end: 2 * pi),
);
```

## Best Practices

### 1. Always Use useAnimationController

```dart
// ✅ Good - automatic disposal
final (controller, animValue) = useAnimationController(
  duration: Duration(seconds: 1),
);

// ❌ Bad - manual disposal
final vsync = useSingleTickerProvider();
final controller = AnimationController(vsync: vsync, duration: Duration(seconds: 1));
onUnmounted(() => controller.dispose());
```

### 2. Use Reactive State to Control Animations

```dart
// ✅ Good - declarative
final isPlaying = ref(false);

watch(() => isPlaying.value, (playing, _) {
  if (playing) {
    controller.repeat();
  } else {
    controller.stop();
  }
});

// ❌ Bad - imperative
void toggleAnimation() {
  if (controller.isAnimating) {
    controller.stop();
  } else {
    controller.repeat();
  }
}
```

### 3. Use Curves for Complex Animations

```dart
// ✅ Good - more natural animation
final curvedAnimation = CurvedAnimation(
  parent: controller,
  curve: Curves.easeInOut,
);

// ❌ Bad - linear animation feels mechanical
// Using controller directly
```

### 4. Clean Up Properly

```dart
// ✅ Good - composables handle automatically
final (controller, _) = useAnimationController(/* ... */);

// ❌ Bad - manual management
final controller = AnimationController(/* ... */);
onUnmounted(() {
  controller.dispose();
  // Easy to forget!
});
```

## Next Steps

- Explore [Form Handling](./forms.md) to build reactive forms
- Learn [Async Operations](./async-operations.md) to handle asynchronous animations
- Read the [useAnimationController API](https://pub.dev/documentation/flutter_compositions/latest/flutter_compositions/useAnimationController.html) for the complete API reference

---

# Forms

Forms are at the core of most applications. This guide will explore how to build reactive forms using Flutter Compositions, including input handling, validation, submission, and error handling.

## Why Use Reactive Forms?

Traditional Flutter form handling requires a lot of boilerplate code:

```dart
// ❌ Traditional approach - lots of boilerplate
class _LoginFormState extends State<LoginForm> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  @override
  void dispose() {
    _emailController.dispose(); // Don't forget!
    _passwordController.dispose();
    super.dispose();
  }

  void _submit() {
    if (_formKey.currentState!.validate()) {
      // Submit
    }
  }
}

// ✅ Compositions approach - clean and reactive
@override
Widget Function(BuildContext) setup() {
  final (emailController, email, _) = useTextEditingController();
  final (passwordController, password, _) = useTextEditingController();

  final isValid = computed(() {
    return email.value.isNotEmpty && password.value.length >= 8;
  });

  return (context) => /* ... */;
}
```

## useTextEditingController - Basic Input

`useTextEditingController` creates a `TextEditingController` with reactive text and selection tracking.

### Simple Text Input

```dart
class SimpleForm extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, text, selection) = useTextEditingController();

    // Reactive computation
    final charCount = computed(() => text.value.length);
    final wordCount = computed(() {
      if (text.value.isEmpty) return 0;
      return text.value.split(' ').where((w) => w.isNotEmpty).length;
    });

    return (context) => Column(
      children: [
        TextField(
          controller: controller.raw, // .raw avoids unnecessary rebuilds
          decoration: InputDecoration(
            labelText: 'Enter text',
            hintText: 'Start typing...',
          ),
        ),
        SizedBox(height: 8),
        Text('Characters: ${charCount.value}'),
        Text('Words: ${wordCount.value}'),
      ],
    );
  }
}
```

### Programmatic Control

```dart
class ControlledInput extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, text, selection) = useTextEditingController(
      text: 'Initial value',
    );

    void clearText() {
      text.value = '';
    }

    void insertTemplate() {
      text.value = 'Dear [Name],\n\n[Content]\n\nBest regards,\n[Your Name]';
    }

    void selectAll() {
      selection.value = TextSelection(
        baseOffset: 0,
        extentOffset: text.value.length,
      );
    }

    void toUpperCase() {
      text.value = text.value.toUpperCase();
    }

    return (context) => Column(
      children: [
        TextField(controller: controller.raw), // .raw avoids unnecessary rebuilds
        Row(
          children: [
            ElevatedButton(
              onPressed: clearText,
              child: Text('Clear'),
            ),
            ElevatedButton(
              onPressed: insertTemplate,
              child: Text('Template'),
            ),
            ElevatedButton(
              onPressed: selectAll,
              child: Text('Select All'),
            ),
            ElevatedButton(
              onPressed: toUpperCase,
              child: Text('Uppercase'),
            ),
          ],
        ),
      ],
    );
  }
}
```

## Form Validation

### Real-time Validation

```dart
class EmailForm extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, email, _) = useTextEditingController();

    // Validation rules
    final isEmailValid = computed(() {
      if (email.value.isEmpty) return null;
      final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
      return emailRegex.hasMatch(email.value);
    });

    final errorText = computed(() {
      final valid = isEmailValid.value;
      if (valid == null) return null;
      return valid ? null : 'Please enter a valid email address';
    });

    return (context) => TextField(
      controller: controller.raw, // .raw avoids unnecessary rebuilds
      decoration: InputDecoration(
        labelText: 'Email',
        errorText: errorText.value,
        suffixIcon: email.value.isNotEmpty
            ? Icon(
                isEmailValid.value == true
                    ? Icons.check_circle
                    : Icons.error,
                color: isEmailValid.value == true
                    ? Colors.green
                    : Colors.red,
              )
            : null,
      ),
      keyboardType: TextInputType.emailAddress,
    );
  }
}
```

### Multi-field Validation

```dart
class RegistrationForm extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (emailController, email, _) = useTextEditingController();
    final (passwordController, password, _) = useTextEditingController();
    final (confirmPasswordController, confirmPassword, _) =
        useTextEditingController();

    // Individual field validation
    final isEmailValid = computed(() {
      if (email.value.isEmpty) return null;
      final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
      return emailRegex.hasMatch(email.value);
    });

    final isPasswordValid = computed(() {
      if (password.value.isEmpty) return null;
      return password.value.length >= 8;
    });

    final isPasswordStrong = computed(() {
      if (password.value.isEmpty) return false;
      final hasUppercase = password.value.contains(RegExp(r'[A-Z]'));
      final hasLowercase = password.value.contains(RegExp(r'[a-z]'));
      final hasDigits = password.value.contains(RegExp(r'[0-9]'));
      return hasUppercase && hasLowercase && hasDigits;
    });

    final doPasswordsMatch = computed(() {
      if (confirmPassword.value.isEmpty) return null;
      return password.value == confirmPassword.value;
    });

    // Overall form validation
    final isFormValid = computed(() {
      return isEmailValid.value == true &&
          isPasswordValid.value == true &&
          doPasswordsMatch.value == true;
    });

    // Error messages
    final emailError = computed(() {
      if (isEmailValid.value == null) return null;
      return isEmailValid.value! ? null : 'Invalid email address';
    });

    final passwordError = computed(() {
      if (isPasswordValid.value == null) return null;
      return isPasswordValid.value! ? null : 'Password must be at least 8 characters';
    });

    final confirmPasswordError = computed(() {
      if (doPasswordsMatch.value == null) return null;
      return doPasswordsMatch.value! ? null : 'Passwords do not match';
    });

    return (context) => Column(
      children: [
        TextField(
          controller: emailController.raw, // .raw avoids unnecessary rebuilds
          decoration: InputDecoration(
            labelText: 'Email',
            errorText: emailError.value,
          ),
          keyboardType: TextInputType.emailAddress,
        ),
        SizedBox(height: 16),
        TextField(
          controller: passwordController.raw, // .raw avoids unnecessary rebuilds
          decoration: InputDecoration(
            labelText: 'Password',
            errorText: passwordError.value,
            helperText: isPasswordStrong.value
                ? 'Strong password'
                : 'Include uppercase, lowercase letters and numbers',
          ),
          obscureText: true,
        ),
        SizedBox(height: 16),
        TextField(
          controller: confirmPasswordController.raw, // .raw avoids unnecessary rebuilds
          decoration: InputDecoration(
            labelText: 'Confirm Password',
            errorText: confirmPasswordError.value,
          ),
          obscureText: true,
        ),
        SizedBox(height: 24),
        ElevatedButton(
          onPressed: isFormValid.value ? () => submitForm() : null,
          child: Text('Register'),
        ),
      ],
    );
  }

  void submitForm() {
    // Submit form
  }
}
```

## Practical Examples

### Login Form

```dart
class LoginForm extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (emailController, email, _) = useTextEditingController();
    final (passwordController, password, _) = useTextEditingController();

    final isLoading = ref(false);
    final error = ref<String?>(null);

    // Validation
    final isEmailValid = computed(() {
      final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
      return emailRegex.hasMatch(email.value);
    });

    final isFormValid = computed(() {
      return isEmailValid.value && password.value.isNotEmpty;
    });

    // Submit
    Future<void> submit() async {
      if (!isFormValid.value) return;

      isLoading.value = true;
      error.value = null;

      try {
        await authService.login(
          email: email.value,
          password: password.value,
        );
        // Navigate to home
      } catch (e) {
        error.value = e.toString();
      } finally {
        isLoading.value = false;
      }
    }

    return (context) => Scaffold(
      appBar: AppBar(title: Text('Login')),
      body: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            if (error.value != null)
              Container(
                padding: EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.red.shade100,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(Icons.error_outline, color: Colors.red),
                    SizedBox(width: 8),
                    Expanded(child: Text(error.value!)),
                  ],
                ),
              ),
            SizedBox(height: 16),
            TextField(
              controller: emailController.raw, // .raw avoids unnecessary rebuilds
              decoration: InputDecoration(
                labelText: 'Email',
                prefixIcon: Icon(Icons.email),
                border: OutlineInputBorder(),
              ),
              keyboardType: TextInputType.emailAddress,
              enabled: !isLoading.value,
            ),
            SizedBox(height: 16),
            TextField(
              controller: passwordController.raw, // .raw avoids unnecessary rebuilds
              decoration: InputDecoration(
                labelText: 'Password',
                prefixIcon: Icon(Icons.lock),
                border: OutlineInputBorder(),
              ),
              obscureText: true,
              enabled: !isLoading.value,
              onSubmitted: (_) => submit(),
            ),
            SizedBox(height: 24),
            SizedBox(
              width: double.infinity,
              height: 48,
              child: ElevatedButton(
                onPressed: isLoading.value || !isFormValid.value
                    ? null
                    : submit,
                child: isLoading.value
                    ? CircularProgressIndicator(color: Colors.white)
                    : Text('Login'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

### Profile Form

```dart
const authServiceKey = InjectionKey<AuthService>('authService');
// Parent needs to provide the instance with provide(authServiceKey, AuthService())

class ProfileForm extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final authService = inject(authServiceKey);

    // Form fields
    final (nameController, name, _) = useTextEditingController();
    final (bioController, bio, _) = useTextEditingController();
    final (websiteController, website, _) = useTextEditingController();
    final avatar = ref<File?>(null);

    // Loading states
    final isLoading = ref(false);
    final isSaving = ref(false);

    // Validation
    final isNameValid = computed(() => name.value.trim().isNotEmpty);

    final isWebsiteValid = computed(() {
      if (website.value.isEmpty) return true;
      final urlRegex = RegExp(
        r'^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b',
      );
      return urlRegex.hasMatch(website.value);
    });

    final hasChanges = ref(false);

    // Load existing profile
    onMounted(() async {
      isLoading.value = true;
      try {
        final profile = await authService.getCurrentUserProfile();
        name.value = profile.name;
        bio.value = profile.bio ?? '';
        website.value = profile.website ?? '';
      } catch (e) {
        // Handle error
      } finally {
        isLoading.value = false;
      }
    });

    // Track changes
    watchEffect(() {
      hasChanges.value = name.value.isNotEmpty ||
          bio.value.isNotEmpty ||
          website.value.isNotEmpty ||
          avatar.value != null;
    });

    // Pick avatar
    Future<void> pickAvatar() async {
      final picker = ImagePicker();
      final image = await picker.pickImage(source: ImageSource.gallery);
      if (image != null) {
        avatar.value = File(image.path);
      }
    }

    // Save
    Future<void> save() async {
      if (!isNameValid.value || !isWebsiteValid.value) return;

      isSaving.value = true;
      try {
        await authService.updateProfile(
          name: name.value,
          bio: bio.value.isEmpty ? null : bio.value,
          website: website.value.isEmpty ? null : website.value,
          avatar: avatar.value,
        );

        // Show success message
        onBuild(() {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Profile updated')),
          );
        });

        hasChanges.value = false;
      } catch (e) {
        // Show error
        onBuild(() {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Failed to update profile'),
              backgroundColor: Colors.red,
            ),
          );
        });
      } finally {
        isSaving.value = false;
      }
    }

    return (context) {
      if (isLoading.value) {
        return Scaffold(
          appBar: AppBar(title: Text('Edit Profile')),
          body: Center(child: CircularProgressIndicator()),
        );
      }

      return Scaffold(
        appBar: AppBar(
          title: Text('Edit Profile'),
          actions: [
            if (hasChanges.value)
              TextButton(
                onPressed: isSaving.value ? null : save,
                child: isSaving.value
                    ? CircularProgressIndicator(color: Colors.white)
                    : Text('Save', style: TextStyle(color: Colors.white)),
              ),
          ],
        ),
        body: SingleChildScrollView(
          padding: EdgeInsets.all(16),
          child: Column(
            children: [
              // Avatar
              GestureDetector(
                onTap: pickAvatar,
                child: CircleAvatar(
                  radius: 50,
                  backgroundImage: avatar.value != null
                      ? FileImage(avatar.value!)
                      : null,
                  child: avatar.value == null
                      ? Icon(Icons.add_a_photo, size: 40)
                      : null,
                ),
              ),
              SizedBox(height: 24),

              // Name
              TextField(
                controller: nameController.raw, // .raw avoids unnecessary rebuilds
                decoration: InputDecoration(
                  labelText: 'Name',
                  border: OutlineInputBorder(),
                  errorText: !isNameValid.value ? 'Name is required' : null,
                ),
              ),
              SizedBox(height: 16),

              // Bio
              TextField(
                controller: bioController.raw, // .raw avoids unnecessary rebuilds
                decoration: InputDecoration(
                  labelText: 'Bio',
                  border: OutlineInputBorder(),
                  hintText: 'Tell us about yourself...',
                ),
                maxLines: 4,
                maxLength: 200,
              ),
              SizedBox(height: 16),

              // Website
              TextField(
                controller: websiteController.raw, // .raw avoids unnecessary rebuilds
                decoration: InputDecoration(
                  labelText: 'Website',
                  border: OutlineInputBorder(),
                  errorText: !isWebsiteValid.value ? 'Invalid URL' : null,
                  hintText: 'https://example.com',
                ),
                keyboardType: TextInputType.url,
              ),
            ],
          ),
        ),
      );
    };
  }
}
```

### Search Form with Filters

```dart
class ProductSearchForm extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (searchController, query, _) = useTextEditingController();
    final category = ref<String>('all');
    final minPrice = ref(0.0);
    final maxPrice = ref(1000.0);
    final sortBy = ref<SortOption>(SortOption.relevance);

    // Debounced search
    final debouncedQuery = ref('');
    Timer? debounceTimer;

    watch(
      () => query.value,
      (newQuery, _) {
        debounceTimer?.cancel();
        debounceTimer = Timer(Duration(milliseconds: 500), () {
          debouncedQuery.value = newQuery;
        });
      },
    );

    onUnmounted(() => debounceTimer?.cancel());

    // Search results
    final (results, refresh) = useAsyncData<List<Product>, SearchParams>(
      (params) => productService.search(params),
      watch: () => SearchParams(
        query: debouncedQuery.value,
        category: category.value,
        minPrice: minPrice.value,
        maxPrice: maxPrice.value,
        sortBy: sortBy.value,
      ),
    );

    // Reset filters
    void resetFilters() {
      searchController.value.clear();
      category.value = 'all';
      minPrice.value = 0.0;
      maxPrice.value = 1000.0;
      sortBy.value = SortOption.relevance;
    }

    return (context) => Column(
      children: [
        // Search bar
        Padding(
          padding: EdgeInsets.all(16),
          child: TextField(
            controller: searchController.raw, // .raw avoids unnecessary rebuilds
            decoration: InputDecoration(
              hintText: 'Search products...',
              prefixIcon: Icon(Icons.search),
              suffixIcon: query.value.isNotEmpty
                  ? IconButton(
                      icon: Icon(Icons.clear),
                      onPressed: () => searchController.value.clear(),
                    )
                  : null,
              border: OutlineInputBorder(),
            ),
          ),
        ),

        // Filters
        ExpansionTile(
          title: Text('Filters'),
          children: [
            // Category
            Padding(
              padding: EdgeInsets.symmetric(horizontal: 16),
              child: DropdownButtonFormField<String>(
                value: category.value,
                decoration: InputDecoration(labelText: 'Category'),
                items: [
                  DropdownMenuItem(value: 'all', child: Text('All')),
                  DropdownMenuItem(value: 'electronics', child: Text('Electronics')),
                  DropdownMenuItem(value: 'clothing', child: Text('Clothing')),
                  DropdownMenuItem(value: 'books', child: Text('Books')),
                ],
                onChanged: (value) => category.value = value!,
              ),
            ),

            // Price range
            Padding(
              padding: EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('Price Range: \$${minPrice.value.toInt()} - \$${maxPrice.value.toInt()}'),
                  RangeSlider(
                    values: RangeValues(minPrice.value, maxPrice.value),
                    min: 0,
                    max: 1000,
                    divisions: 20,
                    onChanged: (values) {
                      minPrice.value = values.start;
                      maxPrice.value = values.end;
                    },
                  ),
                ],
              ),
            ),

            // Sort
            Padding(
              padding: EdgeInsets.symmetric(horizontal: 16),
              child: DropdownButtonFormField<SortOption>(
                value: sortBy.value,
                decoration: InputDecoration(labelText: 'Sort By'),
                items: [
                  DropdownMenuItem(value: SortOption.relevance, child: Text('Relevance')),
                  DropdownMenuItem(value: SortOption.priceLow, child: Text('Price: Low to High')),
                  DropdownMenuItem(value: SortOption.priceHigh, child: Text('Price: High to Low')),
                  DropdownMenuItem(value: SortOption.newest, child: Text('Newest')),
                ],
                onChanged: (value) => sortBy.value = value!,
              ),
            ),

            // Reset button
            Padding(
              padding: EdgeInsets.all(16),
              child: TextButton(
                onPressed: resetFilters,
                child: Text('Reset Filters'),
              ),
            ),
          ],
        ),

        // Results
        Expanded(
          child: switch (results.value) {
            AsyncLoading() => Center(child: CircularProgressIndicator()),
            AsyncError(:final errorValue) => Center(
              child: Text('Error: $errorValue'),
            ),
            AsyncData(:final value) => value.isEmpty
                ? Center(child: Text('No products found'))
                : ListView.builder(
                    itemCount: value.length,
                    itemBuilder: (context, index) {
                      return ProductCard(product: value[index]);
                    },
                  ),
            AsyncIdle() => SizedBox.shrink(),
          },
        ),
      ],
    );
  }
}

class SearchParams {
  const SearchParams({
    required this.query,
    required this.category,
    required this.minPrice,
    required this.maxPrice,
    required this.sortBy,
  });

  final String query;
  final String category;
  final double minPrice;
  final double maxPrice;
  final SortOption sortBy;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SearchParams &&
          query == other.query &&
          category == other.category &&
          minPrice == other.minPrice &&
          maxPrice == other.maxPrice &&
          sortBy == other.sortBy;

  @override
  int get hashCode => Object.hash(query, category, minPrice, maxPrice, sortBy);
}

enum SortOption { relevance, priceLow, priceHigh, newest }
```

### Dynamic Forms

```dart
class DynamicSurveyForm extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final questions = ref<List<Question>>([
      Question(
        id: '1',
        text: 'What is your age range?',
        type: QuestionType.radio,
        options: ['18-25', '26-35', '36-45', '46+'],
      ),
      Question(
        id: '2',
        text: 'What topics interest you?',
        type: QuestionType.checkbox,
        options: ['Technology', 'Sports', 'Arts', 'Music'],
      ),
      Question(
        id: '3',
        text: 'Additional comments',
        type: QuestionType.text,
      ),
    ]);

    final answers = ref<Map<String, dynamic>>({});

    void updateAnswer(String questionId, dynamic answer) {
      final newAnswers = Map<String, dynamic>.from(answers.value);
      newAnswers[questionId] = answer;
      answers.value = newAnswers;
    }

    final isComplete = computed(() {
      return questions.value.every((q) => answers.value.containsKey(q.id));
    });

    Future<void> submit() async {
      // Submit survey
      print('Submitting answers: ${answers.value}');
    }

    return (context) => Scaffold(
      appBar: AppBar(title: Text('Survey')),
      body: ListView.builder(
        padding: EdgeInsets.all(16),
        itemCount: questions.value.length,
        itemBuilder: (context, index) {
          final question = questions.value[index];

          return Card(
            margin: EdgeInsets.only(bottom: 16),
            child: Padding(
              padding: EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    question.text,
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  SizedBox(height: 12),
                  _buildQuestionInput(question, answers, updateAnswer),
                ],
              ),
            ),
          );
        },
      ),
      bottomNavigationBar: Padding(
        padding: EdgeInsets.all(16),
        child: ElevatedButton(
          onPressed: isComplete.value ? submit : null,
          child: Text('Submit'),
        ),
      ),
    );
  }

  Widget _buildQuestionInput(
    Question question,
    Ref<Map<String, dynamic>> answers,
    void Function(String, dynamic) updateAnswer,
  ) {
    switch (question.type) {
      case QuestionType.radio:
        return Column(
          children: question.options!.map((option) {
            return RadioListTile<String>(
              title: Text(option),
              value: option,
              groupValue: answers.value[question.id],
              onChanged: (value) => updateAnswer(question.id, value),
            );
          }).toList(),
        );

      case QuestionType.checkbox:
        return Column(
          children: question.options!.map((option) {
            final selected = (answers.value[question.id] as List?)?.contains(option) ?? false;
            return CheckboxListTile(
              title: Text(option),
              value: selected,
              onChanged: (checked) {
                final current = List<String>.from(
                  (answers.value[question.id] as List?) ?? [],
                );
                if (checked!) {
                  current.add(option);
                } else {
                  current.remove(option);
                }
                updateAnswer(question.id, current);
              },
            );
          }).toList(),
        );

      case QuestionType.text:
        return TextField(
          decoration: InputDecoration(
            border: OutlineInputBorder(),
            hintText: 'Enter your answer...',
          ),
          maxLines: 3,
          onChanged: (value) => updateAnswer(question.id, value),
        );
    }
  }
}

class Question {
  const Question({
    required this.id,
    required this.text,
    required this.type,
    this.options,
  });

  final String id;
  final String text;
  final QuestionType type;
  final List<String>? options;
}

enum QuestionType { radio, checkbox, text }
```

## Custom Validation

Create reusable validation composables:

```dart
// Email validation composable
ValidationResult useEmailValidation(Ref<String> email) {
  final isValid = computed(() {
    if (email.value.isEmpty) return null;
    final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
    return emailRegex.hasMatch(email.value);
  });

  final errorText = computed(() {
    if (isValid.value == null) return null;
    return isValid.value! ? null : 'Please enter a valid email address';
  });

  return ValidationResult(
    isValid: isValid,
    errorText: errorText,
  );
}

// Password validation composable
ValidationResult usePasswordValidation(Ref<String> password) {
  final isValid = computed(() {
    if (password.value.isEmpty) return null;
    return password.value.length >= 8;
  });

  final strength = computed(() {
    if (password.value.isEmpty) return PasswordStrength.none;

    var score = 0;
    if (password.value.length >= 8) score++;
    if (password.value.contains(RegExp(r'[A-Z]'))) score++;
    if (password.value.contains(RegExp(r'[a-z]'))) score++;
    if (password.value.contains(RegExp(r'[0-9]'))) score++;
    if (password.value.contains(RegExp(r'[!@#$%^&*()]'))) score++;

    if (score <= 2) return PasswordStrength.weak;
    if (score <= 3) return PasswordStrength.medium;
    return PasswordStrength.strong;
  });

  final errorText = computed(() {
    if (isValid.value == null) return null;
    return isValid.value! ? null : 'Password must be at least 8 characters';
  });

  return ValidationResult(
    isValid: isValid,
    errorText: errorText,
    strength: strength,
  );
}

class ValidationResult {
  const ValidationResult({
    required this.isValid,
    required this.errorText,
    this.strength,
  });

  final ComputedRef<bool?> isValid;
  final ComputedRef<String?> errorText;
  final ComputedRef<PasswordStrength>? strength;
}

enum PasswordStrength { none, weak, medium, strong }
```

## Best Practices

### 1. Use useTextEditingController

```dart
// ✅ Good - automatic disposal
final (controller, text, _) = useTextEditingController();

// ❌ Bad - manual disposal required
final controller = TextEditingController();
onUnmounted(() => controller.dispose());
```

### 2. Real-time Validation Instead of On-Submit

```dart
// ✅ Good - instant feedback
final isEmailValid = computed(() {
  final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
  return emailRegex.hasMatch(email.value);
});

// ❌ Bad - only validate on submit
void submit() {
  if (!isEmailValid(email.value)) {
    // Too late
  }
}
```

### 3. Debounce Search Input

```dart
// ✅ Good - debounce to reduce API calls
final debouncedQuery = ref('');
Timer? debounceTimer;

watch(() => query.value, (newQuery, _) {
  debounceTimer?.cancel();
  debounceTimer = Timer(Duration(milliseconds: 500), () {
    debouncedQuery.value = newQuery;
  });
});
```

### 4. Show Validation Feedback

```dart
// ✅ Good - visual feedback
TextField(
  decoration: InputDecoration(
    errorText: errorText.value,
    suffixIcon: isValid.value == true
        ? Icon(Icons.check_circle, color: Colors.green)
        : null,
  ),
);
```

### 5. Handle Loading States

```dart
// ✅ Good - disable during submission
ElevatedButton(
  onPressed: isLoading.value ? null : submit,
  child: isLoading.value
      ? CircularProgressIndicator()
      : Text('Submit'),
);
```

## Next Steps

- Explore [Async Operations](./async-operations.md) for handling form submission
- Learn [State Management](./state-management.md) for managing form state
- Read the [useTextEditingController API](./built-in-composables.md#usetexteditingcontroller) for full API reference

---

# State Management

Managing application state is crucial to building scalable Flutter applications. This guide explores how to manage local and global state using Flutter Compositions, share state using provide/inject, and common state patterns.

## Types of State

In Flutter Compositions, we distinguish between three types of state:

### 1. Local State

State that is only used within a single widget. Should be defined in that widget's `setup()` method.

```dart
class CounterButton extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    // Local state - only this widget needs it
    final count = ref(0);

    return (context) => ElevatedButton(
      onPressed: () => count.value++,
      child: Text('Clicks: ${count.value}'),
    );
  }
}
```

### 2. Shared State (Widget Tree Scoped)

State that multiple widgets need, but limited to a specific part of the widget tree. Share using `provide`/`inject`.

```dart
const todosKey = InjectionKey<Ref<List<Todo>>>('todos');

// Provide in parent widget
class TodoListPage extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final todos = ref(<Todo>[]);
    provide(todosKey, todos); // Provide to child widgets

    return (context) => Column(
      children: [
        TodoInput(),
        TodoList(),
        TodoStats(),
      ],
    );
  }
}

// Inject in child widget
class TodoStats extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final todos = inject(todosKey); // Inject shared state

    final count = computed(() => todos.value.length);

    return (context) => Text('Total ${count.value} todos');
  }
}
```

### 3. Global State (Application Scoped)

State that the entire application needs. Provide at the application root, inject anywhere.

```dart
// Define global state
class AuthState {
  final user = ref<User?>(null);
  final isAuthenticated = ref(false);

  Future<void> login(String email, String password) async {
    // Login logic
    user.value = await api.login(email, password);
    isAuthenticated.value = true;
  }

  void logout() {
    user.value = null;
    isAuthenticated.value = false;
  }
}

const authStateKey = InjectionKey<AuthState>('authState');

// Provide at application root
class MyApp extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final authState = AuthState();
    provide(authStateKey, authState);

    return (context) => MaterialApp(
      home: HomePage(),
    );
  }
}

// Use in any child widget
class ProfilePage extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final authState = inject(authStateKey);

    return (context) {
      if (!authState.isAuthenticated.value) {
        return LoginPage();
      }

      return Column(
        children: [
          Text('Welcome, ${authState.user.value?.name}'),
          ElevatedButton(
            onPressed: authState.logout,
            child: Text('Logout'),
          ),
        ],
      );
    };
  }
}
```

## State Sharing with Provide/Inject

### Basic Usage

```dart
const themeKey = InjectionKey<ThemeState>('theme');

// 1. Define state to share
class ThemeState {
  final isDark = ref(false);

  void toggleTheme() {
    isDark.value = !isDark.value;
  }
}

// 2. Provide in parent widget
class App extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final theme = ThemeState();
    provide(themeKey, theme);

    return (context) => MaterialApp(
      home: HomePage(),
    );
  }
}

// 3. Inject in child widget
class ThemeToggle extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final theme = inject(themeKey);

    return (context) => Switch(
      value: theme.isDark.value,
      onChanged: (_) => theme.toggleTheme(),
    );
  }
}
```

### Type-Safe Injection

To avoid type collisions and provide better developer experience, use `InjectionKey`:

```dart
// Define injection key
class ThemeStateKey extends InjectionKey<ThemeState> {
  const ThemeStateKey();
}

const themeKey = ThemeStateKey();

// Provide using key
class App extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final theme = ThemeState();
    provide(themeKey, theme);

    return (context) => MaterialApp(home: HomePage());
  }
}

// Inject using key
class ThemeToggle extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final theme = inject(themeKey);

    return (context) => Switch(
      value: theme.isDark.value,
      onChanged: (_) => theme.toggleTheme(),
    );
  }
}
```

### Providing Default Values

```dart
const settingsKey = InjectionKey<SettingsState>('settings');

class SettingsState {
  final fontSize = ref(14.0);
}

class MyWidget extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    // Use default value if not found
    final settings = inject(
      settingsKey,
      defaultValue: SettingsState(),
    );

    return (context) => Text(
      'Hello',
      style: TextStyle(fontSize: settings.fontSize.value),
    );
  }
}
```

## State Patterns

### Pattern 1: Repository Pattern

Separate data access logic from UI.

```dart
// Repository
class UserRepository {
  final _users = ref(<User>[]);
  final _isLoading = ref(false);
  final _error = ref<String?>(null);

  ReadonlyRef<List<User>> get users => _users;
  ReadonlyRef<bool> get isLoading => _isLoading;
  ReadonlyRef<String?> get error => _error;

  Future<void> fetchUsers() async {
    _isLoading.value = true;
    _error.value = null;

    try {
      final result = await api.getUsers();
      _users.value = result;
    } catch (e) {
      _error.value = e.toString();
    } finally {
      _isLoading.value = false;
    }
  }

  Future<void> addUser(User user) async {
    try {
      await api.createUser(user);
      _users.value = [..._users.value, user];
    } catch (e) {
      _error.value = e.toString();
    }
  }

  Future<void> deleteUser(String userId) async {
    try {
      await api.deleteUser(userId);
      _users.value = _users.value.where((u) => u.id != userId).toList();
    } catch (e) {
      _error.value = e.toString();
    }
  }
}

const userRepositoryKey = InjectionKey<UserRepository>('userRepository');

// Provide in application
class App extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final userRepo = UserRepository();
    provide(userRepositoryKey, userRepo);

    return (context) => MaterialApp(home: UserListPage());
  }
}

// Use in UI
class UserListPage extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final userRepo = inject(userRepositoryKey);

    onMounted(() {
      userRepo.fetchUsers();
    });

    return (context) {
      if (userRepo.isLoading.value) {
        return Center(child: CircularProgressIndicator());
      }

      if (userRepo.error.value != null) {
        return Center(child: Text('Error: ${userRepo.error.value}'));
      }

      return ListView.builder(
        itemCount: userRepo.users.value.length,
        itemBuilder: (context, index) {
          final user = userRepo.users.value[index];
          return ListTile(
            title: Text(user.name),
            trailing: IconButton(
              icon: Icon(Icons.delete),
              onPressed: () => userRepo.deleteUser(user.id),
            ),
          );
        },
      );
    };
  }
}
```

### Pattern 2: Store Pattern (Similar to Vuex/Pinia)

Centrally manage state, getters, actions, and mutations.

```dart
// Store
class TodoStore {
  // State
  final _todos = ref(<Todo>[]);
  final _filter = ref<TodoFilter>(TodoFilter.all);

  // Getters (readonly)
  ReadonlyRef<List<Todo>> get todos => _todos;
  ReadonlyRef<TodoFilter> get filter => _filter;

  // Computed
  late final activeTodos = computed(() {
    return _todos.value.where((t) => !t.completed).toList();
  });

  late final completedTodos = computed(() {
    return _todos.value.where((t) => t.completed).toList();
  });

  late final filteredTodos = computed(() {
    switch (_filter.value) {
      case TodoFilter.active:
        return activeTodos.value;
      case TodoFilter.completed:
        return completedTodos.value;
      case TodoFilter.all:
        return _todos.value;
    }
  });

  late final stats = computed(() => TodoStats(
    total: _todos.value.length,
    active: activeTodos.value.length,
    completed: completedTodos.value.length,
  ));

  // Actions
  void addTodo(String title) {
    final todo = Todo(
      id: DateTime.now().toString(),
      title: title,
      completed: false,
    );
    _todos.value = [..._todos.value, todo];
  }

  void removeTodo(String id) {
    _todos.value = _todos.value.where((t) => t.id != id).toList();
  }

  void toggleTodo(String id) {
    _todos.value = _todos.value.map((t) {
      if (t.id == id) {
        return Todo(id: t.id, title: t.title, completed: !t.completed);
      }
      return t;
    }).toList();
  }

  void setFilter(TodoFilter newFilter) {
    _filter.value = newFilter;
  }

  void clearCompleted() {
    _todos.value = activeTodos.value;
  }
}

enum TodoFilter { all, active, completed }

class TodoStats {
  const TodoStats({
    required this.total,
    required this.active,
    required this.completed,
  });

  final int total;
  final int active;
  final int completed;
}
```

### Pattern 3: Service Pattern

Encapsulate business logic in services.

```dart
// Service
class AuthService {
  final _currentUser = ref<User?>(null);
  final _isAuthenticated = ref(false);

  ReadonlyRef<User?> get currentUser => _currentUser;
  ReadonlyRef<bool> get isAuthenticated => _isAuthenticated;

  Future<void> login(String email, String password) async {
    try {
      final user = await api.login(email, password);
      _currentUser.value = user;
      _isAuthenticated.value = true;

      // Save token
      await storage.saveToken(user.token);
    } catch (e) {
      rethrow;
    }
  }

  Future<void> logout() async {
    _currentUser.value = null;
    _isAuthenticated.value = false;
    await storage.deleteToken();
  }

  Future<void> checkAuth() async {
    final token = await storage.getToken();
    if (token != null) {
      try {
        final user = await api.getCurrentUser(token);
        _currentUser.value = user;
        _isAuthenticated.value = true;
      } catch (e) {
        await logout();
      }
    }
  }
}

class NotificationService {
  final _notifications = ref(<Notification>[]);
  final _unreadCount = ref(0);

  ReadonlyRef<List<Notification>> get notifications => _notifications;
  ReadonlyRef<int> get unreadCount => _unreadCount;

  void addNotification(Notification notification) {
    _notifications.value = [..._notifications.value, notification];
    if (!notification.read) {
      _unreadCount.value++;
    }
  }

  void markAsRead(String id) {
    _notifications.value = _notifications.value.map((n) {
      if (n.id == id && !n.read) {
        _unreadCount.value--;
        return Notification(id: n.id, message: n.message, read: true);
      }
      return n;
    }).toList();
  }

  void clearAll() {
    _notifications.value = [];
    _unreadCount.value = 0;
  }
}

const authServiceKey = InjectionKey<AuthService>('authService');
const notificationServiceKey =
    InjectionKey<NotificationService>('notificationService');

// Provide all services in application
class App extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final authService = AuthService();
    final notificationService = NotificationService();

    provide(authServiceKey, authService);
    provide(notificationServiceKey, notificationService);

    onMounted(() {
      authService.checkAuth();
    });

    return (context) => MaterialApp(home: HomePage());
  }
}
```

### Pattern 4: Composed State

Compose multiple state sources.

```dart
const appStateKey = InjectionKey<AppState>('appState');

class AppState {
  final auth = AuthService();
  final notifications = NotificationService();
  final theme = ThemeState();
  final settings = SettingsState();
}

class App extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final appState = AppState();
    provide(appStateKey, appState);

    return (context) => MaterialApp(home: HomePage());
  }
}

// Use in child widget
class Header extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final appState = inject(appStateKey);

    final userName = computed(() {
      return appState.auth.currentUser.value?.name ?? 'Guest';
    });

    return (context) => AppBar(
      title: Text('Welcome, ${userName.value}'),
      actions: [
        IconButton(
          icon: Badge(
            label: Text('${appState.notifications.unreadCount.value}'),
            child: Icon(Icons.notifications),
          ),
          onPressed: () {/* Show notifications */},
        ),
      ],
    );
  }
}
```

## Real-World Example: Shopping Application

Let's build a complete state management system for a shopping application.

### Define Domain Models

```dart
class Product {
  const Product({
    required this.id,
    required this.name,
    required this.price,
    required this.imageUrl,
  });

  final String id;
  final String name;
  final double price;
  final String imageUrl;
}

class CartItem {
  const CartItem({
    required this.product,
    required this.quantity,
  });

  final Product product;
  final int quantity;

  double get total => product.price * quantity;
}

class Order {
  const Order({
    required this.id,
    required this.items,
    required this.total,
    required this.status,
    required this.createdAt,
  });

  final String id;
  final List<CartItem> items;
  final double total;
  final OrderStatus status;
  final DateTime createdAt;
}

enum OrderStatus { pending, confirmed, shipped, delivered }
```

### Create Stores

```dart
// Product Store
class ProductStore {
  final _products = ref(<Product>[]);
  final _isLoading = ref(false);
  final _error = ref<String?>(null);

  ReadonlyRef<List<Product>> get products => _products;
  ReadonlyRef<bool> get isLoading => _isLoading;
  ReadonlyRef<String?> get error => _error;

  Future<void> fetchProducts() async {
    _isLoading.value = true;
    _error.value = null;

    try {
      final result = await api.getProducts();
      _products.value = result;
    } catch (e) {
      _error.value = e.toString();
    } finally {
      _isLoading.value = false;
    }
  }

  Product? getProductById(String id) {
    try {
      return _products.value.firstWhere((p) => p.id == id);
    } catch (e) {
      return null;
    }
  }
}

// Cart Store
class CartStore {
  final _items = ref(<String, CartItem>{}); // productId -> CartItem

  ReadonlyRef<Map<String, CartItem>> get items => _items;

  late final itemCount = computed(() {
    return _items.value.values.fold<int>(0, (sum, item) => sum + item.quantity);
  });

  late final total = computed(() {
    return _items.value.values.fold<double>(0.0, (sum, item) => sum + item.total);
  });

  late final isEmpty = computed(() => _items.value.isEmpty);

  void addItem(Product product) {
    final currentItems = Map<String, CartItem>.from(_items.value);

    if (currentItems.containsKey(product.id)) {
      final currentItem = currentItems[product.id]!;
      currentItems[product.id] = CartItem(
        product: product,
        quantity: currentItem.quantity + 1,
      );
    } else {
      currentItems[product.id] = CartItem(product: product, quantity: 1);
    }

    _items.value = currentItems;
  }

  void removeItem(String productId) {
    final currentItems = Map<String, CartItem>.from(_items.value);
    currentItems.remove(productId);
    _items.value = currentItems;
  }

  void updateQuantity(String productId, int quantity) {
    if (quantity <= 0) {
      removeItem(productId);
      return;
    }

    final currentItems = Map<String, CartItem>.from(_items.value);
    if (currentItems.containsKey(productId)) {
      final item = currentItems[productId]!;
      currentItems[productId] = CartItem(
        product: item.product,
        quantity: quantity,
      );
      _items.value = currentItems;
    }
  }

  void clear() {
    _items.value = {};
  }
}

// Order Store
class OrderStore {
  final _orders = ref(<Order>[]);
  final _isLoading = ref(false);

  ReadonlyRef<List<Order>> get orders => _orders;
  ReadonlyRef<bool> get isLoading => _isLoading;

  late final pendingOrders = computed(() {
    return _orders.value.where((o) => o.status == OrderStatus.pending).toList();
  });

  late final completedOrders = computed(() {
    return _orders.value.where((o) => o.status == OrderStatus.delivered).toList();
  });

  Future<void> fetchOrders() async {
    _isLoading.value = true;
    try {
      final result = await api.getOrders();
      _orders.value = result;
    } finally {
      _isLoading.value = false;
    }
  }

  Future<Order?> createOrder(List<CartItem> items, double total) async {
    try {
      final order = await api.createOrder(items, total);
      _orders.value = [..._orders.value, order];
      return order;
    } catch (e) {
      return null;
    }
  }
}
```

### Application Root Setup

```dart
const productStoreKey = InjectionKey<ProductStore>('productStore');
const cartStoreKey = InjectionKey<CartStore>('cartStore');
const orderStoreKey = InjectionKey<OrderStore>('orderStore');
// authServiceKey already defined in previous example

class ShoppingApp extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    // Create all stores
    final productStore = ProductStore();
    final cartStore = CartStore();
    final orderStore = OrderStore();
    final authService = AuthService();

    // Provide to entire application
    provide(productStoreKey, productStore);
    provide(cartStoreKey, cartStore);
    provide(orderStoreKey, orderStore);
    provide(authServiceKey, authService);

    // Initialize
    onMounted(() async {
      await authService.checkAuth();
      if (authService.isAuthenticated.value) {
        await productStore.fetchProducts();
        await orderStore.fetchOrders();
      }
    });

    // Watch cart changes to save locally
    watch(
      () => cartStore.items.value,
      (items, _) async {
        await storage.saveCart(items);
      },
    );

    return (context) => MaterialApp(
      home: HomePage(),
      routes: {
        '/products': (context) => ProductListPage(),
        '/cart': (context) => CartPage(),
        '/orders': (context) => OrderHistoryPage(),
      },
    );
  }
}
```

### Using Stores in Pages

```dart
class ProductListPage extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final productStore = inject(productStoreKey);
    final cartStore = inject(cartStoreKey);

    return (context) {
      if (productStore.isLoading.value) {
        return Center(child: CircularProgressIndicator());
      }

      return Scaffold(
        appBar: AppBar(
          title: Text('Products'),
          actions: [
            IconButton(
              icon: Badge(
                label: Text('${cartStore.itemCount.value}'),
                child: Icon(Icons.shopping_cart),
              ),
              onPressed: () => Navigator.pushNamed(context, '/cart'),
            ),
          ],
        ),
        body: GridView.builder(
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 2,
          ),
          itemCount: productStore.products.value.length,
          itemBuilder: (context, index) {
            final product = productStore.products.value[index];
            return ProductCard(
              product: product,
              onAddToCart: () => cartStore.addItem(product),
            );
          },
        ),
      );
    };
  }
}

class CartPage extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final cartStore = inject(cartStoreKey);
    final orderStore = inject(orderStoreKey);

    Future<void> checkout() async {
      final items = cartStore.items.value.values.toList();
      final total = cartStore.total.value;

      final order = await orderStore.createOrder(items, total);
      if (order != null) {
        cartStore.clear();
        // Navigate to order confirmation page
      }
    }

    return (context) {
      if (cartStore.isEmpty.value) {
        return Scaffold(
          appBar: AppBar(title: Text('Cart')),
          body: Center(child: Text('Cart is empty')),
        );
      }

      return Scaffold(
        appBar: AppBar(title: Text('Cart (${cartStore.itemCount.value})')),
        body: Column(
          children: [
            Expanded(
              child: ListView.builder(
                itemCount: cartStore.items.value.length,
                itemBuilder: (context, index) {
                  final item = cartStore.items.value.values.elementAt(index);
                  return CartItemTile(
                    item: item,
                    onUpdateQuantity: (qty) {
                      cartStore.updateQuantity(item.product.id, qty);
                    },
                    onRemove: () => cartStore.removeItem(item.product.id),
                  );
                },
              ),
            ),
            CartSummary(
              total: cartStore.total.value,
              onCheckout: checkout,
            ),
          ],
        ),
      );
    };
  }
}
```

## Persisting State

### Using SharedPreferences

```dart
class SettingsStore {
  final theme = ref('light');
  final language = ref('en');
  final notifications = ref(true);

  Future<void> load() async {
    final prefs = await SharedPreferences.getInstance();
    theme.value = prefs.getString('theme') ?? 'light';
    language.value = prefs.getString('language') ?? 'en';
    notifications.value = prefs.getBool('notifications') ?? true;
  }

  Future<void> save() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('theme', theme.value);
    await prefs.setString('language', language.value);
    await prefs.setBool('notifications', notifications.value);
  }
}

// Usage
const settingsStoreKey = InjectionKey<SettingsStore>('settingsStore');

class App extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final settings = SettingsStore();
    provide(settingsStoreKey, settings);

    onMounted(() async {
      await settings.load();
    });

    // Watch changes and auto-save
    watchEffect(() {
      settings.save();
    });

    return (context) => MaterialApp(home: HomePage());
  }
}
```

### Using Hive

```dart
class UserStore {
  final _users = ref(<User>[]);

  Future<void> load() async {
    final box = await Hive.openBox<User>('users');
    _users.value = box.values.toList();
  }

  Future<void> addUser(User user) async {
    final box = await Hive.openBox<User>('users');
    await box.add(user);
    _users.value = [..._users.value, user];
  }

  Future<void> deleteUser(int index) async {
    final box = await Hive.openBox<User>('users');
    await box.deleteAt(index);
    _users.value = List.from(_users.value)..removeAt(index);
  }
}
```

## Best Practices

### 1. Keep State Close to Where It's Used

```dart
// ❌ Bad - All state is global
class GlobalState {
  final buttonColor = ref(Colors.blue);
  final textValue = ref('');
  // ... 100 other fields
}

// ✅ Good - Only share necessary state
class App extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    // Only provide truly global state
    final authService = AuthService();
    provide(authServiceKey, authService);

    return (context) => MaterialApp(home: HomePage());
  }
}
```

### 2. Expose State as Readonly References

```dart
// ✅ Good - Prevent external direct modification
class CounterStore {
  final _count = ref(0);

  // Expose as readonly
  ReadonlyRef<int> get count => _count;

  // Modify through methods
  void increment() => _count.value++;
}
```

### 3. Group Related State

```dart
// ✅ Good - Logical grouping
class UserState {
  final profile = ref<UserProfile?>(null);
  final preferences = ref(UserPreferences());
  final settings = ref(UserSettings());
}
```

### 4. Use Computed Instead of Repeated Calculations

```dart
class TodoStore {
  final _todos = ref(<Todo>[]);

  // ✅ Good - Cached computation
  late final activeTodos = computed(() {
    return _todos.value.where((t) => !t.completed).toList();
  });

  // ❌ Bad - Recompute every time
  List<Todo> getActiveTodos() {
    return _todos.value.where((t) => !t.completed).toList();
  }
}
```

### 5. Handle Error States

```dart
class DataStore<T> {
  final _data = ref<T?>(null);
  final _isLoading = ref(false);
  final _error = ref<String?>(null);

  ReadonlyRef<T?> get data => _data;
  ReadonlyRef<bool> get isLoading => _isLoading;
  ReadonlyRef<String?> get error => _error;

  Future<void> fetch(Future<T> Function() fetcher) async {
    _isLoading.value = true;
    _error.value = null;

    try {
      _data.value = await fetcher();
    } catch (e) {
      _error.value = e.toString();
    } finally {
      _isLoading.value = false;
    }
  }
}
```

## Testing State Management

```dart
void main() {
  group('CartStore', () {
    late CartStore cartStore;

    setUp(() {
      cartStore = CartStore();
    });

    test('should add item to cart', () {
      final product = Product(
        id: '1',
        name: 'Test',
        price: 10.0,
        imageUrl: '',
      );

      cartStore.addItem(product);

      expect(cartStore.itemCount.value, 1);
      expect(cartStore.total.value, 10.0);
    });

    test('should update quantity', () {
      final product = Product(
        id: '1',
        name: 'Test',
        price: 10.0,
        imageUrl: '',
      );

      cartStore.addItem(product);
      cartStore.updateQuantity('1', 3);

      expect(cartStore.itemCount.value, 3);
      expect(cartStore.total.value, 30.0);
    });

    test('should remove item', () {
      final product = Product(
        id: '1',
        name: 'Test',
        price: 10.0,
        imageUrl: '',
      );

      cartStore.addItem(product);
      cartStore.removeItem('1');

      expect(cartStore.isEmpty.value, true);
    });
  });
}
```

## Next Steps

- Explore [Dependency Injection](./dependency-injection.md) for deeper understanding of provide/inject
- Learn [Async Operations](./async-operations.md) for handling API calls
- Read [Best Practices](./best-practices.md) for advanced patterns

---

# Creating Your Own Composables

The built-in `use` functions are convenient, but the real power of `flutter_compositions` comes from the ability to easily create your own composable functions (Composables).

## What is a Composable?

A Composable is a regular Dart function whose name starts with `use`. It allows you to encapsulate reactive logic and lifecycle management related to a specific feature so that it can be reused across different `CompositionWidget`s.

The main benefits of creating your own Composables are:

- **Logic Reusability**: Extract stateful logic from your widgets to avoid writing the same code over and over.
- **Separation of Concerns**: Keep your `setup` methods clean and focused on composing different Composables, rather than implementing all the details.
- **Testability**: Independent Composable functions are easier to unit test than large widgets.

## Example: Creating `useOrientation`

Let's create a `useOrientation` Composable that returns a reactive `Ref` indicating the current device orientation (portrait or landscape).

**1. Create a `use_media_query.dart` file**

```dart
import 'package:flutter/widgets.dart';
import 'package:flutter_compositions/flutter_compositions.dart';

// A Composable is just a function that starts with `use`
(Ref<Size>, Ref<Orientation>) useMediaQuery() {
  // 1. Create refs to store reactive values
  final size = ref(Size.zero);
  final orientation = ref(Orientation.portrait);

  // 2. Use onBuild to access BuildContext on each build
  // This allows us to react to MediaQuery changes
  onBuild((context) {
    final mediaQuery = MediaQuery.of(context);
    size.value = mediaQuery.size;
    orientation.value = mediaQuery.orientation;
  });

  // 3. Return the reactive references
  return (size, orientation);
}
```

**Important Tip**: The example above uses `onBuild()` to access `BuildContext` on each build. This is the recommended way to integrate with Flutter's `InheritedWidget` system (like `MediaQuery`, `Theme`, etc.).

**Alternative - Using useContextRef()**: If you need to access context-dependent values reactively, use `useContextRef()`:

```dart
ReadonlyRef<OverlayState> useOverlayState() {
  return useContextRef((context) => Overlay.of(context));
}
```

**2. Use It in Your Widget**

Now, you can use `useMediaQuery` in your `setup` method just like any built-in Composable.

```dart
import '../en/guide/use_media_query.dart'; // Import the Composable you created

class ResponsiveWidget extends CompositionWidget {
  const ResponsiveWidget({super.key});

  @override
  Widget Function(BuildContext) setup() {
    // Call it just like a built-in function
    final (screenSize, orientation) = useMediaQuery();

    // Create computed properties based on screen info
    final isPortrait = computed(() => orientation.value == Orientation.portrait);
    final isSmallScreen = computed(() => screenSize.value.width < 600);

    final message = computed(() {
      final orientationText = isPortrait.value ? 'Portrait' : 'Landscape';
      final sizeText = isSmallScreen.value ? 'Small' : 'Large';
      return 'Screen: $sizeText, $orientationText (${screenSize.value.width.toInt()}x${screenSize.value.height.toInt()})';
    });

    return (context) => Scaffold(
      appBar: AppBar(title: const Text('Responsive')),
      body: Center(
        child: Text(message.value), // The UI will react to changes automatically
      ),
    );
  }
}
```

Using this pattern, you can create all sorts of reusable logic, such as:

- `useConnectivity()`: To monitor network connection status.
- `useGeolocation()`: To track the user's geographical location.
- `useForm()`: To encapsulate the state and validation logic of a complex form.

Decomposing your application logic into small, manageable, and reusable Composables is the best practice when working with `flutter_compositions`.

---

# Migrating from StatefulWidget

This guide helps you transition from `StatefulWidget` to `CompositionWidget` by showing equivalent patterns side-by-side.

## Table of Contents

1. [Basic Counter](#basic-counter)
2. [Controllers](#controllers)
3. [Lifecycle Methods](#lifecycle-methods)
4. [State Dependencies](#state-dependencies)
5. [Forms](#forms)
6. [Async Operations](#async-operations)
7. [Animations](#animations)
8. [Navigation](#navigation)

## Basic Counter

### StatefulWidget

```dart
class Counter extends StatefulWidget {
  const Counter({super.key});

  @override
  State<Counter> createState() => _CounterState();
}

class _CounterState extends State<Counter> {
  int _count = 0;

  void _increment() {
    setState(() {
      _count++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Count: $_count'),
        ElevatedButton(
          onPressed: _increment,
          child: const Text('Increment'),
        ),
      ],
    );
  }
}
```

### CompositionWidget

```dart
class Counter extends CompositionWidget {
  const Counter({super.key});

  @override
  Widget Function(BuildContext) setup() {
    // Reactive state - no setState needed
    final count = ref(0);

    void increment() => count.value++;

    return (context) => Column(
      children: [
        Text('Count: ${count.value}'),
        ElevatedButton(
          onPressed: increment,
          child: const Text('Increment'),
        ),
      ],
    );
  }
}
```

**Key Differences**:
- ✅ No separate State class
- ✅ No `setState()` calls
- ✅ Direct value updates trigger automatic rebuilds
- ✅ Cleaner, more concise code

## Controllers

### StatefulWidget

```dart
class ScrollExample extends StatefulWidget {
  @override
  State<ScrollExample> createState() => _ScrollExampleState();
}

class _ScrollExampleState extends State<ScrollExample> {
  late ScrollController _scrollController;
  double _scrollOffset = 0;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
    _scrollController.addListener(_onScroll);
  }

  void _onScroll() {
    setState(() {
      _scrollOffset = _scrollController.offset;
    });
  }

  @override
  void dispose() {
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Offset: $_scrollOffset'),
        Expanded(
          child: ListView.builder(
            controller: _scrollController,
            itemCount: 100,
            itemBuilder: (context, index) => ListTile(
              title: Text('Item $index'),
            ),
          ),
        ),
      ],
    );
  }
}
```

### CompositionWidget

```dart
class ScrollExample extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    // Auto-disposed controller with reactive offset
    final scrollController = useScrollController();

    final scrollOffset = computed(() {
      // Automatically tracks controller changes
      return scrollController.value.offset;
    });

    return (context) => Column(
      children: [
        Text('Offset: ${scrollOffset.value.toStringAsFixed(1)}'),
        Expanded(
          child: ListView.builder(
            controller: scrollController.raw, // .raw avoids unnecessary rebuilds
            itemCount: 100,
            itemBuilder: (context, index) => ListTile(
              title: Text('Item $index'),
            ),
          ),
        ),
      ],
    );
  }
}
```

**Key Differences**:
- ✅ Automatic disposal (no manual cleanup)
- ✅ No listener management
- ✅ Reactive offset tracking with `computed`
- ✅ Less boilerplate

## Lifecycle Methods

### StatefulWidget

```dart
class LifecycleExample extends StatefulWidget {
  @override
  State<LifecycleExample> createState() => _LifecycleExampleState();
}

class _LifecycleExampleState extends State<LifecycleExample> {
  late Timer _timer;

  @override
  void initState() {
    super.initState();
    print('Widget created');

    WidgetsBinding.instance.addPostFrameCallback((_) {
      print('Widget mounted (first frame)');
    });

    _timer = Timer.periodic(Duration(seconds: 1), (timer) {
      print('Timer tick');
    });
  }

  @override
  void dispose() {
    print('Widget disposing');
    _timer.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    print('Building widget');
    return Container();
  }
}
```

### CompositionWidget

```dart
class LifecycleExample extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    print('Setup (runs once)');

    onMounted(() {
      print('Widget mounted (first frame)');

      // Timer automatically managed
      final timer = Timer.periodic(Duration(seconds: 1), (timer) {
        print('Timer tick');
      });

      onUnmounted(() {
        print('Cleaning up timer');
        timer.cancel();
      });
    });

    onUnmounted(() {
      print('Widget unmounted');
    });

    onBuild((context) {
      print('Building widget');
    });

    return (context) => Container();
  }
}
```

**Key Differences**:
- ✅ Clear lifecycle hook names
- ✅ Multiple onMounted/onUnmounted supported
- ✅ onBuild hook for build-time logic
- ✅ Cleanup callbacks colocated with initialization

## State Dependencies

### StatefulWidget

```dart
class DependentState extends StatefulWidget {
  @override
  State<DependentState> createState() => _DependentStateState();
}

class _DependentStateState extends State<DependentState> {
  int _count = 0;
  late String _message;

  @override
  void initState() {
    super.initState();
    _updateMessage();
  }

  void _updateMessage() {
    setState(() {
      _message = _count == 0 ? 'Start' : 'Count: $_count';
    });
  }

  void _increment() {
    setState(() {
      _count++;
      _updateMessage();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(_message),
        ElevatedButton(
          onPressed: _increment,
          child: const Text('Increment'),
        ),
      ],
    );
  }
}
```

### CompositionWidget

```dart
class DependentState extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final count = ref(0);

    // Automatically updates when count changes
    final message = computed(() =>
      count.value == 0 ? 'Start' : 'Count: ${count.value}'
    );

    void increment() => count.value++;

    return (context) => Column(
      children: [
        Text(message.value),
        ElevatedButton(
          onPressed: increment,
          child: const Text('Increment'),
        ),
      ],
    );
  }
}
```

**Key Differences**:
- ✅ Automatic dependency tracking
- ✅ No manual updates needed
- ✅ Cleaner derived state with `computed`

## Forms

### StatefulWidget

```dart
class LoginForm extends StatefulWidget {
  @override
  State<LoginForm> createState() => _LoginFormState();
}

class _LoginFormState extends State<LoginForm> {
  late TextEditingController _emailController;
  late TextEditingController _passwordController;
  bool _isValid = false;

  @override
  void initState() {
    super.initState();
    _emailController = TextEditingController();
    _passwordController = TextEditingController();

    _emailController.addListener(_validate);
    _passwordController.addListener(_validate);
  }

  void _validate() {
    setState(() {
      _isValid = _emailController.text.isNotEmpty &&
                 _passwordController.text.length >= 6;
    });
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _submit() {
    if (_isValid) {
      print('Email: ${_emailController.text}');
      print('Password: ${_passwordController.text}');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TextField(
          controller: _emailController,
          decoration: InputDecoration(labelText: 'Email'),
        ),
        TextField(
          controller: _passwordController,
          decoration: InputDecoration(labelText: 'Password'),
          obscureText: true,
        ),
        ElevatedButton(
          onPressed: _isValid ? _submit : null,
          child: Text('Submit'),
        ),
      ],
    );
  }
}
```

### CompositionWidget

```dart
class LoginForm extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (emailController, email, _) = useTextEditingController();
    final (passwordController, password, _) = useTextEditingController();

    // Reactive validation
    final isValid = computed(() =>
      email.value.isNotEmpty && password.value.length >= 6
    );

    void submit() {
      if (isValid.value) {
        print('Email: ${email.value}');
        print('Password: ${password.value}');
      }
    }

    return (context) => Column(
      children: [
        TextField(
          controller: emailController,
          decoration: InputDecoration(labelText: 'Email'),
        ),
        TextField(
          controller: passwordController,
          decoration: InputDecoration(labelText: 'Password'),
          obscureText: true,
        ),
        ElevatedButton(
          onPressed: isValid.value ? submit : null,
          child: Text('Submit'),
        ),
      ],
    );
  }
}
```

**Key Differences**:
- ✅ Automatic controller disposal
- ✅ Reactive text binding
- ✅ Computed validation
- ✅ No manual listener management

## Async Operations

### StatefulWidget

```dart
class UserProfile extends StatefulWidget {
  final int userId;
  const UserProfile({required this.userId});

  @override
  State<UserProfile> createState() => _UserProfileState();
}

class _UserProfileState extends State<UserProfile> {
  User? _user;
  bool _loading = true;
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadUser();
  }

  @override
  void didUpdateWidget(UserProfile oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.userId != oldWidget.userId) {
      _loadUser();
    }
  }

  Future<void> _loadUser() async {
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final user = await api.fetchUser(widget.userId);
      if (mounted) {
        setState(() {
          _user = user;
          _loading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = e.toString();
          _loading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_loading) return CircularProgressIndicator();
    if (_error != null) return Text('Error: $_error');
    if (_user == null) return Text('No user');
    return Text('User: ${_user!.name}');
  }
}
```

### CompositionWidget

```dart
class UserProfile extends CompositionWidget {
  final int userId;
  const UserProfile({required this.userId});

  @override
  Widget Function(BuildContext) setup() {
    final props = widget();

    // Auto-refetch when userId changes
    final (userData, _) = useAsyncData<User, int>(
      (userId) => api.fetchUser(userId),
      watch: () => props.value.userId,
    );

    return (context) => switch (userData.value) {
      AsyncLoading() => CircularProgressIndicator(),
      AsyncError(:final errorValue) => Text('Error: $errorValue'),
      AsyncData(:final value) => Text('User: ${value.name}'),
      AsyncIdle() => Text('No user'),
    };
  }
}
```

**Key Differences**:
- ✅ Automatic refetch on prop changes
- ✅ Built-in loading/error/data states
- ✅ No mounted checks needed
- ✅ Pattern matching for clean state handling

## Animations

### StatefulWidget

```dart
class FadeInWidget extends StatefulWidget {
  @override
  State<FadeInWidget> createState() => _FadeInWidgetState();
}

class _FadeInWidgetState extends State<FadeInWidget>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _opacity;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: Duration(seconds: 1),
      vsync: this,
    );

    _opacity = Tween<double>(begin: 0.0, end: 1.0).animate(_controller);

    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _opacity,
      builder: (context, child) => Opacity(
        opacity: _opacity.value,
        child: child,
      ),
      child: Container(child: Text('Hello')),
    );
  }
}
```

### CompositionWidget

```dart
class FadeInWidget extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (controller, animValue) = useAnimationController(
      duration: Duration(seconds: 1),
    );

    final opacity = computed(() => animValue.value);

    onMounted(() => controller.forward());

    return (context) => Opacity(
      opacity: opacity.value,
      child: Container(child: Text('Hello')),
    );
  }
}
```

**Key Differences**:
- ✅ No mixin required
- ✅ Automatic disposal
- ✅ Reactive animation value
- ✅ Cleaner API

## Prop Reactivity

### StatefulWidget

```dart
class UserGreeting extends StatefulWidget {
  final String username;
  const UserGreeting({required this.username});

  @override
  State<UserGreeting> createState() => _UserGreetingState();
}

class _UserGreetingState extends State<UserGreeting> {
  late String _greeting;

  @override
  void initState() {
    super.initState();
    _updateGreeting();
  }

  @override
  void didUpdateWidget(UserGreeting oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.username != oldWidget.username) {
      _updateGreeting();
    }
  }

  void _updateGreeting() {
    setState(() {
      _greeting = 'Hello, ${widget.username}!';
    });
  }

  @override
  Widget build(BuildContext context) {
    return Text(_greeting);
  }
}
```

### CompositionWidget

```dart
class UserGreeting extends CompositionWidget {
  final String username;
  const UserGreeting({required this.username});

  @override
  Widget Function(BuildContext) setup() {
    final props = widget();

    // Automatically updates when username changes
    final greeting = computed(() => 'Hello, ${props.value.username}!');

    return (context) => Text(greeting.value);
  }
}
```

**Key Differences**:
- ✅ No `didUpdateWidget` needed
- ✅ Automatic prop change detection
- ✅ Cleaner reactive code

## Migration Checklist

When migrating from StatefulWidget:

- [ ] Replace State class with `setup()` method
- [ ] Convert `setState(() => field = value)` to `ref.value = value`
- [ ] Replace `initState` logic with `setup()` body
- [ ] Replace `dispose` with `onUnmounted`
- [ ] Use `onMounted` for post-first-frame logic
- [ ] Replace controllers with `use*` helpers
- [ ] Use `widget()` for reactive prop access
- [ ] Convert derived state to `computed`
- [ ] Replace listeners with `watch` or `watchEffect`
- [ ] Test that hot reload works correctly

## Best Practices

### ✅ Do

```dart
// Use refs for mutable state
final count = ref(0);

// Use computed for derived state
final doubled = computed(() => count.value * 2);

// Use composables for reusable logic
final (controller, text) = useTextEditingController();

// Use widget() for props
final props = widget();
final name = computed(() => props.value.username);
```

### ❌ Don't

```dart
// Don't use mutable fields
int count = 0; // ❌ Not reactive

// Don't access props directly in setup
final name = this.username; // ❌ Not reactive

// Don't forget .value
if (count == 5) { /* ❌ compares Ref objects */ }

// Don't manually dispose when using use* helpers
final controller = useScrollController();
controller.value.dispose(); // ❌ Already handled
```

## Conclusion

CompositionWidget offers a more modern, reactive approach to Flutter state management while maintaining full compatibility with Flutter's widget system. The migration path is straightforward, and the benefits in code clarity and maintainability are significant.

For more information:
- [Introduction](./introduction.md) — what Flutter Compositions offers vs. alternatives
- [Reactivity Fundamentals](./reactivity-fundamentals.md)
- [Built-in Composables](./built-in-composables.md)
- [Creating Composables](./creating-composables.md)

---

# Best Practices

This guide distills patterns, performance tips, and team conventions that help real-world Flutter Compositions apps stay maintainable and testable.

## Table of Contents

1. [Composition Patterns](#composition-patterns)
2. [State Management](#state-management)
3. [Performance](#performance)
4. [Project Structure](#project-structure)
5. [Lint Workflow](#lint-workflow)
6. [Testing Strategy](#testing-strategy)
7. [Common Pitfalls](#common-pitfalls)
8. [Further Reading](#further-reading)

## Composition Patterns

### Extract Logic into Composables

Encapsulate reusable state and side effects in functions so multiple widgets do not repeat the same `setup()` code.

```dart
// ✅ Return only what callers need
(Ref<String>, Ref<bool>) useValidatedInput({
  String initialValue = '',
  int minLength = 6,
}) {
  final value = ref(initialValue);
  final isValid = computed(() => value.value.trim().length >= minLength);
  return (value, isValid);
}

class LoginForm extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final (email, emailValid) = useValidatedInput(minLength: 5);
    final (password, passwordValid) = useValidatedInput(minLength: 8);
    final canSubmit = computed(() => emailValid.value && passwordValid.value);

    return (context) => ElevatedButton(
          onPressed: canSubmit.value ? () => submit(email.value) : null,
          child: const Text('Sign in'),
        );
  }
}
```

### Keep the Builder Function Pure — No Logic Inside

The builder function returned by `setup()` should only build the widget tree. **Do not put conditionals, computations, or side effects inside the builder** — move them into `setup()` using `computed`, `watch`, or composables. The only exception is **props destructuring**, which must stay in the builder to maintain reactive access via `props.value`.

```dart
// ❌ Bad: logic inside the builder function
@override
Widget Function(BuildContext) setup() {
  final items = ref(<Item>[]);
  final filter = ref('');

  return (context) {
    // ❌ This filtering logic should be a computed in setup()
    final filtered = items.value
        .where((item) => item.name.contains(filter.value))
        .toList();
    final count = filtered.length;

    return Column(
      children: [
        Text('$count items'),
        ...filtered.map((item) => ItemTile(item: item)),
      ],
    );
  };
}

// ✅ Good: logic in setup(), builder only builds UI
@override
Widget Function(BuildContext) setup() {
  final items = ref(<Item>[]);
  final filter = ref('');
  final filtered = computed(
    () => items.value.where((item) => item.name.contains(filter.value)).toList(),
  );

  return (context) {
    // ✅ Props destructuring is the only exception
    // final MyWidget(:title, :subtitle) = props.value;

    return Column(
      children: [
        Text('${filtered.value.length} items'),
        ...filtered.value.map((item) => ItemTile(item: item)),
      ],
    );
  };
}
```

This ensures that all derived state is properly cached by `computed` and only recalculated when dependencies change, rather than recomputing on every build.

### Keep `setup()` Synchronous

`setup()` must return a builder synchronously. Move asynchronous work into lifecycle hooks.

```dart
@override
Widget Function(BuildContext) setup() {
  final profile = ref<User?>(null);
  final loading = ref(true);

  onMounted(() async {
    profile.value = await api.fetchProfile();
    loading.value = false;
  });

  return (context) => loading.value
      ? const CircularProgressIndicator()
      : Text(profile.value!.name);
}
```

### Model Domain State Explicitly

Prefer dedicated classes over raw `Map<String, dynamic>` so renames and refactors stay safe.

```dart
class SessionState {
  final user = ref<User?>(null);
  final isAuthenticated = ref(false);
}
```

### Handle Side Effects with Watchers

Keep navigation, analytics, and logging inside `watch`/`watchEffect` so cleanup happens automatically.

```dart
watch(() => session.isAuthenticated.value, (isAuthed, _) {
  if (!isAuthed) navigator.showLogin();
});
```

## State Management

### Scope State Deliberately

- **Local state** lives in a single widget—declare it with `ref`.
- **Shared state** spans a subtree—use `provide`/`inject`.
- **Global state** should be provided from the app shell or a top-level feature.

```dart
const sessionKey = InjectionKey<SessionState>('session');

class AppShell extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final session = SessionState();
    provide(sessionKey, session);
    return (context) => const HomePage();
  }
}

class ProfileMenu extends CompositionWidget {
  @override
  Widget Function(BuildContext) setup() {
    final session = inject(sessionKey);
    return (context) => Text(session.user.value?.name ?? 'Guest');
  }
}
```

### Keep Dependency Injection Type-Safe

- Always declare an `InjectionKey<T>` even if there is only one instance today.
- Provide dependencies at the highest sensible level and inject them where needed.
- Supply defaults via `inject(key, defaultValue: ...)` for optional services.

### Represent Async Work with `AsyncValue`

- Wrap async results in `AsyncValue<T>` so loading, error, and data states stay co-located with the UI.
- Expose refresh callbacks returned by `useAsyncData` when you need pull-to-refresh or retry flows.

## Performance

- **Cache expensive computations** with `computed` instead of recomputing inside builders.
- **Limit builder dependencies** to the refs that matter; move static UI into `const` widgets.
- **Avoid creating controllers in builders**—use `useScrollController`, `useAnimationController`, and friends inside `setup()`.
- **Break large widgets apart** once they grow beyond ~150 lines so only the changing subtree rebuilds.

```dart
@override
Widget Function(BuildContext) setup() {
  final todos = ref(<Todo>[]);
  final completed = computed(
    () => todos.value.where((todo) => todo.isDone).toList(growable: false),
  );

  return (context) => Column(
        children: [
          Text('Completed ${completed.value.length} items'),
          Expanded(child: TodoList(todos: todos.value)),
        ],
      );
}
```

## Project Structure

1. **Name composables descriptively**—`useDebouncedSearch()` communicates intent better than `useSearch()`.
2. **Group by feature**: `lib/features/<feature>/composables`, `services`, `widgets`, plus shared utilities.
3. **Expose a narrow public API** from each feature package and co-locate tests alongside implementations.

Example layout:

```
lib/
├── features/
│   └── checkout/
│       ├── composables/
│       │   ├── use_cart.dart
│       │   └── use_checkout_flow.dart
│       ├── services/
│       │   └── checkout_service.dart
│       └── widgets/
│           └── checkout_page.dart
└── shared/
    ├── services/
    └── widgets/
```

## Lint Workflow

- Add `custom_lint` and `flutter_compositions_lints` to `dev_dependencies`.
- Enable the plugin in `analysis_options.yaml`.
- Run `dart run custom_lint --watch` during development and `--fix` before committing.
- Consult the [Lint guide](../lints/index.md) for rule descriptions and IDE integration.

```yaml
dev_dependencies:
  custom_lint: ^0.7.0
  flutter_compositions_lints: ^0.1.0

analyzer:
  plugins:
    - custom_lint

custom_lint:
  enable_all_lint_rules: true
```

## Testing Strategy

### Test Composables Directly

Use `CompositionBuilder` or call the composable function and assert on the returned refs.

```dart
test('useCounter increments', () {
  final (count, increment) = useCounter(initialValue: 0);
  increment();
  expect(count.value, 1);
});
```

### Test Widgets with Injected Fakes

```dart
testWidgets('ProfilePage shows the user name', (tester) async {
  final mockSession = SessionState()..user.value = User(name: 'Alice');

  await tester.pumpWidget(
    CompositionBuilder(
      setup: () {
        provide(sessionKey, mockSession);
        return (context) => const MaterialApp(home: ProfilePage());
      },
    ),
  );

  await tester.pumpAndSettle();
  expect(find.text('Alice'), findsOneWidget);
});
```

- Inject spies or fakes via `provide` instead of mutating globals.
- Call `pump`/`pumpAndSettle` after triggering side effects so watchers can flush updates.

## Common Pitfalls

- Making `setup()` `async`—move await logic into `onMounted`.
- Accessing props via `this`/`widget` instead of `widget<T>()`, which breaks reactivity.
- Reordering or removing `ref` declarations and relying on hot reload; restart when layout changes dramatically.
- Forgetting to clean up external resources—use `onUnmounted` or the built-in `use*` helpers.

## Further Reading

- [Introduction](./introduction.md)
- [Reactivity Fundamentals](./reactivity-fundamentals.md)
- [Async Operations](./async-operations.md)
- [Dependency Injection](./dependency-injection.md)
- [Lint Guide](../lints/index.md)
- [Testing Guide](../testing/testing-guide.md)

---

# Architecture Overview

This page explains how Flutter Compositions layers a composition-oriented runtime on top of Flutter's widget system.

## Key Components

| Component | Responsibility |
|-----------|----------------|
| `CompositionWidget` | Developer-facing widget (extends `StatelessWidget`) that exposes `setup()` and returns a builder |
| `_CompositionElement` | Custom `StatelessElement` that manages lifecycle, runs `setup()`, and registers reactive effects |
| `SetupContextImpl` | Internal container that stores refs, lifecycle hooks, effect scopes, and provided values |
| `alien_signals` runtime | Provides the reactive core (`Ref`, `ComputedRef`, effects) |

## Widget Lifecycle

1. **Mount** — creates `SetupContext`, sets up parent chain for `provide`/`inject`, creates `_widgetSignal` for reactive props, runs `setup()` inside an `effectScope`, stores the returned builder, schedules `onMounted` callbacks for the post-frame.

2. **Build** — the builder runs inside a reactive effect. Reading any ref inside the builder registers the effect as a subscriber. When dependencies change, `markNeedsBuild()` is called directly.

3. **Props update** — `update(newWidget)` fires, calling `_widgetSignal.call(widget)`. Dependent computed values recompute, triggering the builder if needed.

4. **Dependencies change** — `didChangeDependencies()` triggers `onBuild` callbacks for `InheritedWidget` integration.

5. **Unmount** — invokes `onUnmounted` callbacks, disposes the effect scope (which cleans up all refs, computed values, watchers), and tears down the `SetupContext`.

## Setup Execution Flow

```
mount()
  → Create SetupContext
  → Set up parent context (for provide/inject)
  → Create _widgetSignal (for reactive props)
  → Run setup() inside effectScope (once)
  → Store returned builder function
  → Schedule onMounted callbacks for post-frame
```

## Reactive Update Flow

```
ref.value = newValue
  → Signal notifies subscribers
  → Effects queued in microtask (batched)
  → Builder effect re-runs
  → markNeedsBuild() called
  → Flutter rebuilds the element
```

## Builders as Effects

The builder returned from `setup()` runs inside a reactive `effect`. This means:

- Reading a ref inside the builder **registers** the effect as a subscriber
- When any subscribed ref changes, the effect re-runs
- The effect calls `markNeedsBuild()`, triggering a standard Flutter rebuild
- Flutter diffs the widget tree as usual

## Cleanup Semantics

`onCleanup` (exposed via helpers like `watch`) registers teardown logic that fires when the effect is disposed or recreated. This guarantees that listeners, timers, and controllers are properly cleared.

Example from `useStream`:

```dart
final subscription = stream.listen((value) {
  ref.value = value;
});
onCleanup(subscription.cancel);
```

## Controller Management

Helpers like `useScrollController` and `useAnimationController` automatically:

1. Create the controller once during setup
2. Register a cleanup to dispose the controller on unmount
3. Bridge imperative events into refs so UI stays reactive

## Provide/Inject Architecture

The DI system uses a **parent chain** (not `InheritedWidget`) for dependency injection:

- `SetupContext._parent` links to the nearest ancestor `CompositionWidget`'s context
- O(d) lookup where d = widget tree depth
- Does **not** propagate rebuilds — refs handle reactivity
- Type-safe via `InjectionKey<T>` (generic type participates in equality)

```
inject(key)
  → Check current SetupContext._providedValues
  → Walk _parent chain upward
  → Return first match or throw
```

## Error Handling

- Unhandled exceptions from `setup()` bubble up like any Flutter error
- Inside effects, errors are caught and rethrown asynchronously so Flutter's error widget shows useful stack traces

## Performance Architecture

All reactive widgets use a unified StatelessWidget + custom Element architecture:

- **2 objects instead of 3** per widget (no separate `State` object)
- **Direct `markNeedsBuild()`** instead of `setState()` (saves ~200-500 CPU cycles per update)
- **No closure creation** for setState (saves ~30 CPU cycles per update)
- **Memory savings**: ~48-56 bytes per widget instance (15-20% reduction)

This implementation is inspired by [solidart PR #143](https://github.com/nank1ro/solidart/pull/143) and [flutter_hooks](https://github.com/rrousselGit/flutter_hooks).

## Further Reading

- [Reactivity System](./reactivity-system.md) — how dependency tracking works
- [Performance](./performance.md) — optimization strategies
- [Design Trade-offs](./design-trade-offs.md) — deliberate design decisions

---

# Reactivity System

This document explains how Flutter Compositions builds fine-grained reactivity on top of Flutter's widget system using `alien_signals`.

## Building Blocks

### Ref

`ref(value)` returns a `Ref<T>` — a wrapper that tracks reads and writes to `.value`.

- **Reads** register the current reactive observer (builder, computed, or effect)
- **Writes** mark the ref as dirty and notify subscribers

### Computed

`computed(() => ...)` lazily evaluates a function and caches the result until any dependency changes. It behaves like a memoized getter.

- Only computes when first accessed (lazy evaluation)
- Caches results until a dependency changes
- Can itself be a dependency for other computed values or effects

### Effect

Effects are registered by builders, `watch`, or `watchEffect`. Each effect captures the refs it touches and reruns when any of them change.

## Dependency Tracking

The dependency tracking algorithm follows the same model popularized by Vue's reactivity system:

1. Before a reactive function executes, the runtime pushes it onto a **"current observer" stack**
2. When a ref's getter runs, it attaches the current observer to its **subscriber list**
3. Once the function finishes, the observer is **popped** from the stack
4. When `.value` is written, every subscriber is **queued for re-execution**

```
┌─────────────────────────────────────────────┐
│  Effect/Computed runs                       │
│    → Push onto observer stack               │
│    → Read ref.value                         │
│       → ref registers this observer         │
│    → Read computed.value                    │
│       → computed registers this observer    │
│    → Pop from observer stack                │
└─────────────────────────────────────────────┘

┌─────────────────────────────────────────────┐
│  ref.value = newValue                       │
│    → Mark ref as dirty                      │
│    → Queue all subscribers for re-execution │
│    → Microtask scheduler deduplicates       │
│    → Each observer re-executes in order     │
└─────────────────────────────────────────────┘
```

## Scheduler

Updates are batched in a microtask queue:

1. A setter marks the ref dirty and enqueues observers
2. The runtime **deduplicates** observers to avoid redundant work
3. Once the microtask runs, each observer executes in order
4. Builders wrap their work via `markNeedsBuild()`, so Flutter sees them as ordinary widget updates

## Integration with Flutter

- `CompositionWidget` runs `setup()` once, grabs the returned builder, and registers it as an effect
- When dependencies change, the builder triggers `markNeedsBuild()`, scheduling a rebuild that Flutter diffs like any other widget
- Lifecycle hooks (`onMounted`, `onUnmounted`, `onBuild`) piggyback on Flutter's lifecycle and the reactive scheduler

## Effect Scope

All effects created during `setup()` are tracked via `effectScope`:

- Registered in `SetupContext._effectScope`
- Automatically disposed when the widget unmounts
- No manual cleanup needed for `watch`, `watchEffect`, or builder effects

## ComputedBuilder

`ComputedBuilder` wraps a section of UI in its own reactive effect. It observes the refs read inside the provided builder and only rebuilds that subtree when one of those refs changes.

- Use it to isolate hot spots that update frequently
- Pair it with `computed` values so expensive derivations only re-run when needed
- Prefer small builders for maximum effectiveness

## Avoiding Common Pitfalls

- **Stale props**: Access props via `widget()` so you get a reactive wrapper around the latest widget instance
- **Mutable collections**: Replace lists or maps wholesale (`todos.value = [...todos.value, todo]`) so the runtime sees a new reference
- **Async gaps**: When mixing async callbacks and refs, read the latest value inside the callback instead of capturing stale data

## Tooling Hooks

The runtime exposes `onCleanup` behind the scenes so every effect can register teardown logic. Composables like `watch` and `useStream` rely on it to remove listeners automatically.

## Performance Characteristics

| Operation | Complexity |
|-----------|-----------|
| Ref read | O(1) |
| Ref write | O(n) where n = subscriber count |
| Computed evaluation | O(1) amortized (cached) |
| Builder rebuild | Only widgets reading changed refs |
| Dependency tracking | O(1) per read |

## Further Reading

- [Architecture Overview](./architecture.md) — component layout and lifecycle
- [Performance](./performance.md) — optimization implementation details
- [Reactivity Fundamentals](../guide/reactivity-fundamentals.md) — user-facing API guide

---

# Performance

## Minimizing Rebuilds

- The builder only re-executes when the `ref` or `computed` values it reads change.
- Combined with `ComputedBuilder` or splitting into smaller widgets, you can further narrow the rebuild scope.

### Performance Optimization Implementation

All reactive widgets (`ComputedBuilder`, `CompositionWidget`, `CompositionBuilder`) have adopted optimized rebuild mechanisms:

**ComputedBuilder Optimization**:

Uses a custom Element implementation to provide optimal performance:
- **Lower Latency**: 15-25% reduction in single-update latency (for simple widgets)
- **Less Memory**: ~56 bytes reduction per instance (~15%)
- **Direct Rebuild**: Uses `markNeedsBuild()` instead of `setState()`, avoiding microtask scheduling overhead
- **Predictable Batching**: More consistent batch behavior for synchronous updates

Technical details:
- Removes `scheduleMicrotask` overhead (saves ~200-500 CPU cycles per update)
- Removes `setState` closure creation (saves ~30 CPU cycles)
- No State object needed, reducing memory footprint and GC pressure

**CompositionWidget and CompositionBuilder Optimization**:

Uses direct `markNeedsBuild()` calls instead of `setState()`:
- **Reduced Overhead**: Saves ~50 CPU cycles per reactive update
- **Faster Response**: No need to create setState closure (saves ~30 cycles)
- **Fewer Checks**: Avoids setState debug assertions (saves ~15 cycles)
- **Overall Improvement**: 5-10% performance improvement for reactive updates

All optimizations maintain API backward compatibility, requiring no changes to existing code.

## Batch Updates

- Multiple `.value = ...` operations are batched within the same microtask, avoiding redundant rebuilds.
- If you need to immediately see intermediate states, you can use `await Future.microtask((){})` to force update segmentation.

## Best Practices

- Use `computed` to cache expensive calculations, such as sorting, filtering, or statistics.
- Only read necessary refs in the builder; other data can be passed through `const` widgets or split into child widgets.
- Use `provide` / `inject` to pass `Ref` instead of directly passing large objects, ensuring only actual consumers rebuild.

## Monitoring and Debugging

- Use `watchEffect` to temporarily observe dependencies, combined with `debugPrint` to confirm which values trigger updates.
- If state becomes inconsistent after Hot Reload, check whether the `ref` declaration order has been changed.

## Further Reading

- [Best Practices Guide](../guide/best-practices.md)
- [Reactivity System](./reactivity-system.md)

---

# Design Trade-offs

Flutter Compositions prioritises developer ergonomics and fine-grained updates. These choices come with deliberate trade-offs.

## Familiar API vs. Flutter Conventions

- **Pro:** Developers coming from Vue or React Hooks feel at home with `setup()`, `ref`, `computed`, and lifecycle hooks.
- **Con:** The API diverges from idiomatic Flutter Widget patterns, so newcomers need to learn an additional abstraction.

## Runtime Layer

- **Pro:** The `alien_signals` based runtime gives precise dependency tracking and automatic clean-up.
- **Con:** It adds a thin layer above Flutter’s standard lifecycle, which can complicate debugging when mixing with legacy `StatefulWidget`s.

## Single `setup()` Execution

- **Pro:** Declaring state inside `setup()` mirrors Vue’s Composition API and guarantees predictable lifecycle behaviour.
- **Con:** Props are not reactive unless you access them via `widget<T>()`, which is easy to forget.

## Hot Reload Semantics

- **Pro:** Hot reload reruns `setup()` and restores refs by declaration order, so state sticks around during iterative work.
- **Con:** Reordering or removing refs can shuffle the saved state; team members need to know when a hot restart is safer.

## Dependency Injection Scope

- **Pro:** Keys provide compile-time safety without the ceremony of `InheritedWidget`.
- **Con:** Everything lives in memory; there is no lazy-loading or auto-disposal for provided values unless you add it manually.

## Granular Rebuilds

- **Pro:** Builders only rerun when the refs they read change, keeping UI updates tight.
- **Con:** Debug tools like Flutter Inspector expect widget rebuilds; when less of the tree rebuilds, it can feel unfamiliar.

## Recommended Mitigations

- Adopt team lint rules to enforce `widget<T>()` and `InjectionKey` usage.
- Wrap legacy widgets progressively; mixing paradigms is supported but requires clear coding standards.
- Document how and where services are provided so onboarding stays smooth.
- Define a project structure for composables/services (e.g. `features/<name>/composables`).
- Share hot-reload etiquette so developers know when to restart and how to order refs.

## Related Reading

- [Architecture Overview](./architecture.md)
- [Reactivity System](./reactivity-system.md)

---

# Lint Rules Overview

Flutter Compositions provides custom lint rules to enforce best practices and prevent common mistakes. This guide provides a quick overview of all available rules and how to use them.

## Quick Start

### Installation

Add to your `pubspec.yaml`:

```yaml
dev_dependencies:
  custom_lint: ^0.7.0
  flutter_compositions_lints: ^0.1.0
```

Create or update `analysis_options.yaml`:

```yaml
analyzer:
  plugins:
    - custom_lint

custom_lint:
  enable_all_lint_rules: true
```

### Running Lints

```bash
# Analyze code
dart run custom_lint

# Watch for changes
dart run custom_lint --watch

# Auto-fix issues (where applicable)
dart run custom_lint --fix
```

## All Lint Rules

### Reactivity Rules

Rules that ensure proper reactive state management.

#### `flutter_compositions_ensure_reactive_props`

**Severity:** Warning

Ensures that widget properties are accessed through `widget()` in the `setup()` method to maintain reactivity.

```dart
// ❌ Bad - not reactive
@override
Widget Function(BuildContext) setup() {
  final greeting = 'Hello, $name!'; // Direct access
  return (context) => Text(greeting);
}

// ✅ Good - reactive
@override
Widget Function(BuildContext) setup() {
  final props = widget();
  final greeting = computed(() => 'Hello, ${props.value.name}!');
  return (context) => Text(greeting.value);
}
```

[See detailed documentation →](./rules.md#flutter_compositions_ensure_reactive_props)

---

### Lifecycle Rules

Rules that manage component lifecycle and resource cleanup.

#### `flutter_compositions_no_async_setup`

**Severity:** Error

Prevents `setup()` methods from being async. The setup function must synchronously return a builder function.

```dart
// ❌ Bad - async setup
@override
Future<Widget Function(BuildContext)> setup() async {
  final data = await fetchData();
  return (context) => Text(data);
}

// ✅ Good - use onMounted for async
@override
Widget Function(BuildContext) setup() {
  final data = ref<String?>(null);
  onMounted(() async {
    data.value = await fetchData();
  });
  return (context) => Text(data.value ?? 'Loading...');
}
```

[See detailed documentation →](./rules.md#flutter_compositions_no_async_setup)

#### `flutter_compositions_controller_lifecycle`

**Severity:** Warning

Ensures Flutter controllers are properly disposed using either `use*` helper functions or manual disposal in `onUnmounted()`.

**Detected controller types:**
- ScrollController
- PageController
- TextEditingController
- TabController
- AnimationController
- VideoPlayerController
- WebViewController

```dart
// ❌ Bad - never disposed
@override
Widget Function(BuildContext) setup() {
  final controller = ScrollController();
  return (context) => ListView(controller: controller);
}

// ✅ Good - auto-disposed
@override
Widget Function(BuildContext) setup() {
  final controller = useScrollController();
  return (context) => ListView(controller: controller.raw); // .raw avoids unnecessary rebuilds
}

// ✅ Good - manually disposed
@override
Widget Function(BuildContext) setup() {
  final controller = ScrollController();
  onUnmounted(() => controller.dispose());
  return (context) => ListView(controller: controller);
}
```

[See detailed documentation →](./rules.md#flutter_compositions_controller_lifecycle)

#### `flutter_compositions_no_conditional_composition`

**Severity:** Error

Ensures composition API calls are not placed inside conditionals or loops. Similar to React Hooks rules.

**Flagged composition APIs:**
- Reactivity: `ref`, `computed`, `writableComputed`, `customRef`, `watch`, `watchEffect`
- Lifecycle: `onMounted`, `onUnmounted`
- Dependency injection: `provide`, `inject`
- Controllers: `useController`, `useScrollController`, `usePageController`, `useFocusNode`, `useTextEditingController`, `useValueNotifier`, `useAnimationController`, etc.

```dart
// ❌ Bad - conditional composition
@override
Widget Function(BuildContext) setup() {
  if (someCondition) {
    final count = ref(0); // Don't do this!
  }
  return (context) => Text('Hello');
}

// ✅ Good - composition at top level
@override
Widget Function(BuildContext) setup() {
  final count = ref(0);

  // Conditional logic on values is OK
  if (someCondition) {
    count.value = 10;
  }

  return (context) => Text('${count.value}');
}
```

[See detailed documentation →](./rules.md#flutter_compositions_no_conditional_composition)

---

### Best Practices Rules

General best practice rules for clean code.

#### `flutter_compositions_no_mutable_fields`

**Severity:** Warning

Ensures all fields in CompositionWidget classes are `final`. Mutable state should be managed through `ref()` or `computed()`.

```dart
// ❌ Bad - mutable field
class Counter extends CompositionWidget {
  int count = 0; // Mutable field!

  @override
  Widget Function(BuildContext) setup() {
    return (context) => Text('$count');
  }
}

// ✅ Good - immutable prop, mutable via ref
class Counter extends CompositionWidget {
  final int initialCount;

  @override
  Widget Function(BuildContext) setup() {
    final count = ref(initialCount);
    return (context) => Text('${count.value}');
  }
}
```

[See detailed documentation →](./rules.md#flutter_compositions_no_mutable_fields)

---

## Configuring Rules

### Enable/Disable Specific Rules

In `analysis_options.yaml`:

```yaml
custom_lint:
  rules:
    # Enable specific rules
    - flutter_compositions_ensure_reactive_props: true
    - flutter_compositions_no_async_setup: true

    # Disable specific rules
    - flutter_compositions_no_mutable_fields: false
```

### Disable Rules in Code

#### Per File

```dart
// ignore_for_file: flutter_compositions_ensure_reactive_props
```

#### Per Line

```dart
// ignore: flutter_compositions_ensure_reactive_props
final name = this.name;
```

#### Per Block

```dart
// ignore: flutter_compositions_controller_lifecycle
final controller = ScrollController();
```

## IDE Integration

### VS Code
Run `dart run custom_lint --watch` in a terminal. The built-in Flutter/Dart
extensions surface diagnostics in the editor automatically, and quick fixes
remain available via `Ctrl/Cmd + .`.

### Android Studio / IntelliJ

1. Run `dart run custom_lint` in terminal
2. Lints will appear in the Problems panel
3. Or run `dart run custom_lint --watch` for live updates

## Rule Summary Table

| Rule | Severity | Category | Auto-Fix | Description |
|------|----------|----------|----------|-------------|
| [ensure_reactive_props](./rules.md#flutter_compositions_ensure_reactive_props) | Warning | Reactivity | No | Access props via `widget()` |
| [no_async_setup](./rules.md#flutter_compositions_no_async_setup) | Error | Lifecycle | No | Prevent async setup methods |
| [controller_lifecycle](./rules.md#flutter_compositions_controller_lifecycle) | Warning | Lifecycle | No | Ensure controller disposal |
| [no_mutable_fields](./rules.md#flutter_compositions_no_mutable_fields) | Warning | Best Practices | No | Enforce immutable fields |
| [no_conditional_composition](./rules.md#flutter_compositions_no_conditional_composition) | Error | Lifecycle | No | Prevent conditional composition APIs |

## Common Patterns

### Pattern 1: Reactive Props

Always use `widget()` to access props reactively:

```dart
class UserCard extends CompositionWidget {
  final String name;

  @override
  Widget Function(BuildContext) setup() {
    final props = widget();
    final greeting = computed(() => 'Hello, ${props.value.name}!');
    return (context) => Text(greeting.value);
  }
}
```

### Pattern 2: Controller Management

Always use composables for controllers:

```dart
@override
Widget Function(BuildContext) setup() {
  // ✅ Auto-disposed
  final scrollController = useScrollController();
  final (textController, text, _) = useTextEditingController();
  final (animController, animValue) = useAnimationController(
    duration: Duration(seconds: 1),
  );

  return (context) => /* ... */;
}
```

### Pattern 3: Async Initialization

Use `onMounted()` for async operations:

```dart
@override
Widget Function(BuildContext) setup() {
  final data = ref<String?>(null);
  final isLoading = ref(false);

  onMounted(() async {
    isLoading.value = true;
    try {
      data.value = await fetchData();
    } finally {
      isLoading.value = false;
    }
  });

  return (context) => /* ... */;
}
```

### Pattern 4: Type-Safe DI

Use `InjectionKey` for type-safe dependency injection:

```dart
class ThemeServiceKey extends InjectionKey<ThemeService> {
  const ThemeServiceKey();
}

const themeServiceKey = ThemeServiceKey();

// Provide
provide(themeServiceKey, ThemeService());

// Inject
final theme = inject(themeServiceKey);
```

## Troubleshooting

### Lints not showing up?

1. Make sure `custom_lint` is added to `dev_dependencies`
2. Run `flutter pub get`
3. Restart your IDE
4. Run `dart run custom_lint` manually

### False positives?

1. Check if the lint rule is correctly identifying the issue
2. Use `// ignore:` comments for intentional exceptions
3. Report false positives on [GitHub Issues](https://github.com/yourusername/flutter_compositions/issues)

### Performance issues?

1. Use `dart run custom_lint` instead of `--watch` for large codebases
2. Disable specific rules that are not relevant
3. Run lints in CI/CD instead of locally

## Best Practices

1. **Enable all rules by default** - Start strict, disable selectively
2. **Fix lints before committing** - Keep your codebase clean
3. **Use IDE integration** - Catch issues as you type
4. **Document exceptions** - Always explain `// ignore:` comments
5. **Run in CI/CD** - Enforce rules in your pipeline

## Contributing

Found a false positive or have suggestions for new rules?

1. Check existing issues on [GitHub](https://github.com/yourusername/flutter_compositions/issues)
2. Open a new issue with:
   - Code sample that triggers the lint
   - Expected behavior
   - Actual behavior
3. Submit a PR with:
   - Rule implementation
   - Tests
   - Documentation

## See Also

- [Complete Rules Reference](./rules.md) — detailed documentation for each rule
- [Reactivity Fundamentals](../guide/reactivity-fundamentals.md) — learn reactive patterns
- [Best Practices](../guide/best-practices.md) — general best practices
- [Built-in Composables](../guide/built-in-composables.md) — catalog of built-in helpers

## Quick Reference

### Must-follow Rules (Errors)

These rules prevent bugs and should never be disabled:

- `flutter_compositions_no_async_setup` - Setup must be synchronous
- `flutter_compositions_no_conditional_composition` - Composition APIs must be called unconditionally

### Recommended Rules (Warnings)

These rules enforce best practices:

- `flutter_compositions_ensure_reactive_props` - Props must be reactive
- `flutter_compositions_controller_lifecycle` - Controllers must be disposed
- `flutter_compositions_no_mutable_fields` - Fields should be immutable

---

For detailed documentation of each rule, see [Complete Rules Reference](./rules.md).

---

# Flutter Compositions Lint Rules

Complete reference for all available lint rules.

## Rule Categories

- **Reactivity**: Rules ensuring proper reactive state management
- **Lifecycle**: Rules managing component lifecycle and resource cleanup
- **Best Practices**: General best practice rules

---

## Reactivity Rules

### `flutter_compositions_ensure_reactive_props`

**Category:** Reactivity
**Severity:** Warning
**Auto-fixable:** No

#### Description

Ensures that widget properties are accessed through `widget()` in the `setup()` method to maintain reactivity. Direct property access will not trigger reactive updates.

#### Why it matters

The `setup()` method runs only once. If you directly access `this.propertyName`, you capture a snapshot of the value at setup time. When the parent passes new props, your component won't react to the change.

#### Examples

❌ **Bad:**
```dart
class UserCard extends CompositionWidget {
  final String name;

  @override
  Widget Function(BuildContext) setup() {
    // Captures initial value only - NOT reactive
    final greeting = 'Hello, $name!';
    return (context) => Text(greeting);
  }
}
```

✅ **Good:**
```dart
class UserCard extends CompositionWidget {
  final String name;

  @override
  Widget Function(BuildContext) setup() {
    final props = widget();
    // Reacts to prop changes
    final greeting = computed(() => 'Hello, ${props.value.name}!');
    return (context) => Text(greeting.value);
  }
}
```

---

## Lifecycle Rules

### `flutter_compositions_no_async_setup`

**Category:** Lifecycle
**Severity:** Error
**Auto-fixable:** No

#### Description

Prevents `setup()` methods from being async. The setup function must synchronously return a builder function.

#### Why it matters

Making `setup()` async breaks the composition lifecycle. The framework expects a synchronous builder function return, and async setups can cause timing issues and unpredictable behavior.

#### Examples

❌ **Bad:**
```dart
@override
Future<Widget Function(BuildContext)> setup() async {
  final data = await fetchData();
  return (context) => Text(data);
}
```

✅ **Good:**
```dart
@override
Widget Function(BuildContext) setup() {
  final data = ref<String?>(null);

  onMounted(() async {
    data.value = await fetchData();
  });

  return (context) => Text(data.value ?? 'Loading...');
}
```

### `flutter_compositions_controller_lifecycle`

**Category:** Lifecycle
**Severity:** Warning
**Auto-fixable:** No

#### Description

Ensures Flutter controllers (ScrollController, TextEditingController, etc.) are properly disposed using either:
1. `use*` helper functions (recommended)
2. Manual disposal in `onUnmounted()`

#### Why it matters

Controllers hold native resources and listeners. Failing to dispose them causes memory leaks.

#### Detected controller types

- ScrollController
- PageController
- TextEditingController
- TabController
- AnimationController
- VideoPlayerController
- WebViewController

#### Examples

❌ **Bad:**
```dart
@override
Widget Function(BuildContext) setup() {
  final controller = ScrollController(); // Never disposed!
  return (context) => ListView(controller: controller);
}
```

✅ **Good (Option 1 - Recommended):**
```dart
@override
Widget Function(BuildContext) setup() {
  final controller = useScrollController(); // Auto-disposed
  return (context) => ListView(controller: controller.raw); // .raw avoids unnecessary rebuilds
}
```

✅ **Good (Option 2 - Manual):**
```dart
@override
Widget Function(BuildContext) setup() {
  final controller = ScrollController();
  onUnmounted(() => controller.dispose());
  return (context) => ListView(controller: controller);
}
```

### `flutter_compositions_no_conditional_composition`

**Category:** Lifecycle
**Severity:** Error
**Auto-fixable:** No

#### Description

Ensures composition API calls (`ref()`, `computed()`, `watch()`, `useScrollController()`, etc.) are not placed inside conditionals or loops. Similar to React Hooks rules, composition APIs must be called unconditionally at the top level of `setup()`.

#### Why it matters

Conditional composition API calls can cause:
- Inconsistent ordering of reactive dependencies across renders
- Unpredictable reactivity behavior
- Difficult to debug lifecycle issues
- Memory leaks when cleanup hooks are skipped

#### Flagged composition APIs

- Reactivity: `ref`, `computed`, `writableComputed`, `customRef`, `watch`, `watchEffect`
- Lifecycle: `onMounted`, `onUnmounted`
- Dependency injection: `provide`, `inject`
- Controllers: `useController`, `useScrollController`, `usePageController`, `useFocusNode`, `useTextEditingController`, `useValueNotifier`, `useAnimationController`, `manageListenable`, `manageValueListenable`

#### Examples

❌ **Bad:**
```dart
@override
Widget Function(BuildContext) setup() {
  if (someCondition) {
    final count = ref(0); // ❌ Conditional composition API
  }

  for (var i = 0; i < 10; i++) {
    final item = ref(i); // ❌ Inside loop
  }

  return (context) => Text('Hello');
}
```

✅ **Good:**
```dart
@override
Widget Function(BuildContext) setup() {
  // ✅ Composition APIs at top level
  final count = ref(0);
  final items = ref(<int>[]);

  // ✅ Conditional logic for values is OK
  if (someCondition) {
    count.value = 10;
  }

  return (context) => Text('Count: ${count.value}');
}
```

---

## Best Practices Rules

### `flutter_compositions_shallow_reactivity`

**Category:** Best Practices
**Severity:** Warning
**Auto-fixable:** No

#### Description

Warns about shallow reactivity limitations. Flutter Compositions uses shallow reactivity - only reassigning `.value` triggers updates. Directly mutating properties or array elements will NOT trigger reactive updates.

#### Why it matters

The reactivity system tracks changes to `ref.value` itself, not changes within the object or array. Direct mutations like `ref.value.property = x` or `ref.value[0] = x` won't notify subscribers, leading to stale UI.

#### Examples

❌ **Bad:**
```dart
@override
Widget Function(BuildContext) setup() {
  final user = ref({'name': 'John', 'age': 30});
  final items = ref([1, 2, 3]);

  void updateUser() {
    user.value['name'] = 'Jane'; // Won't trigger update!
  }

  void updateItems() {
    items.value[0] = 10; // Won't trigger update!
    items.value.add(4); // Won't trigger update!
  }

  return (context) => Column(
    children: [
      Text(user.value['name']),
      Text('${items.value[0]}'),
    ],
  );
}
```

✅ **Good:**
```dart
@override
Widget Function(BuildContext) setup() {
  final user = ref({'name': 'John', 'age': 30});
  final items = ref([1, 2, 3]);

  void updateUser() {
    // Create new object to trigger update
    user.value = {...user.value, 'name': 'Jane'};
  }

  void updateItems() {
    // Create new array to trigger update
    items.value = [10, ...items.value.sublist(1)];
    items.value = [...items.value, 4];
  }

  return (context) => Column(
    children: [
      Text(user.value['name']),
      Text('${items.value[0]}'),
    ],
  );
}
```

#### Common mutation patterns to avoid

**Direct property assignment:**
```dart
ref.value['key'] = newValue; // ❌
ref.value.property = newValue; // ❌
ref.value = {...ref.value, 'key': newValue}; // ✅
```

**Array element assignment:**
```dart
ref.value[index] = newValue; // ❌
ref.value = [...ref.value.sublist(0, index), newValue, ...ref.value.sublist(index + 1)]; // ✅
```

**Mutating methods:**
```dart
ref.value.add(item); // ❌
ref.value.remove(item); // ❌
ref.value.clear(); // ❌
ref.value = [...ref.value, item]; // ✅
ref.value = ref.value.where((x) => x != item).toList(); // ✅
ref.value = []; // ✅
```

---

## Disabling Rules

### Per-file

```dart
// ignore_for_file: flutter_compositions_ensure_reactive_props
```

### Per-line

```dart
// ignore: flutter_compositions_ensure_reactive_props
final name = this.name;
```

### In analysis_options.yaml

```yaml
custom_lint:
  rules:
    - flutter_compositions_ensure_reactive_props: false
    - flutter_compositions_no_async_setup: true
```

---

## Contributing

Have suggestions for new rules or improvements to existing ones? Please open an issue or pull request!

---

# Testing Guide

This comprehensive guide covers testing strategies for Flutter Compositions applications, including unit testing composables, widget testing, integration testing, and mocking dependencies.

## Table of Contents

1. [Testing Composables](#testing-composables)
2. [Widget Testing](#widget-testing)
3. [Mocking Dependencies](#mocking-dependencies)
4. [Testing Async Operations](#testing-async-operations)
5. [Testing Patterns](#testing-patterns)
6. [Best Practices](#best-practices)

## Testing Composables

Composables can be tested independently from widgets, making them easy to test in isolation.

### Basic Composable Tests

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_compositions/flutter_compositions.dart';

void main() {
  group('useCounter', () {
    test('should start with initial value', () {
      final (count, increment) = useCounter(initialValue: 5);

      expect(count.value, 5);
    });

    test('should increment count', () {
      final (count, increment) = useCounter(initialValue: 0);

      increment();
      expect(count.value, 1);

      increment();
      expect(count.value, 2);
    });

    test('should decrement count', () {
      final (count, increment, decrement) = useCounter(initialValue: 10);

      decrement();
      expect(count.value, 9);
    });
  });
}

// Example composable
(Ref<int>, void Function(), void Function()) useCounter({int initialValue = 0}) {
  final count = ref(initialValue);

  void increment() => count.value++;
  void decrement() => count.value--;

  return (count, increment, decrement);
}
```

### Testing Composables with Watch

Test that watchers trigger correctly:

```dart
test('should call watch callback when value changes', () {
  final values = <int>[];
  final count = ref(0);

  watch(() => count.value, (newValue, oldValue) {
    values.add(newValue);
  });

  count.value = 1;
  count.value = 2;
  count.value = 3;

  // Wait for microtasks to complete
  await Future.delayed(Duration.zero);

  expect(values, [1, 2, 3]);
});
```

### Testing Computed Values

```dart
test('should recompute when dependencies change', () {
  final firstName = ref('John');
  final lastName = ref('Doe');

  final fullName = computed(() => '${firstName.value} ${lastName.value}');

  expect(fullName.value, 'John Doe');

  firstName.value = 'Jane';
  expect(fullName.value, 'Jane Doe');

  lastName.value = 'Smith';
  expect(fullName.value, 'Jane Smith');
});
```

## Widget Testing

### Testing CompositionWidgets

Use Flutter's standard widget testing tools:

```dart
testWidgets('Counter increments when button pressed', (tester) async {
  await tester.pumpWidget(
    MaterialApp(home: CounterPage()),
  );

  // Verify initial state
  expect(find.text('0'), findsOneWidget);
  expect(find.text('1'), findsNothing);

  // Tap increment button
  await tester.tap(find.byIcon(Icons.add));
  await tester.pump();

  // Verify updated state
  expect(find.text('0'), findsNothing);
  expect(find.text('1'), findsOneWidget);
});
```

### Testing Reactive Props

Test that widgets respond to prop changes:

```dart
testWidgets('Widget updates when props change', (tester) async {
  Future<void> buildWidget(String name) async {
    await tester.pumpWidget(
      MaterialApp(
        home: UserGreeting(username: name),
      ),
    );
  }

  await buildWidget('Alice');
  expect(find.text('Hello, Alice!'), findsOneWidget);

  await buildWidget('Bob');
  await tester.pump();
  expect(find.text('Hello, Bob!'), findsOneWidget);
});

class UserGreeting extends CompositionWidget {
  final String username;
  const UserGreeting({required this.username});

  @override
  Widget Function(BuildContext) setup() {
    final props = widget();
    final greeting = computed(() => 'Hello, ${props.value.username}!');

    return (context) => Text(greeting.value);
  }
}
```

### Testing with CompositionBuilder

Use `CompositionBuilder` for testing without creating widget classes:

```dart
testWidgets('CompositionBuilder test', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      home: CompositionBuilder(
        setup: () {
          final count = ref(0);

          return (context) => Scaffold(
            body: Center(child: Text('${count.value}')),
            floatingActionButton: FloatingActionButton(
              onPressed: () => count.value++,
              child: Icon(Icons.add),
            ),
          );
        },
      ),
    ),
  );

  expect(find.text('0'), findsOneWidget);

  await tester.tap(find.byType(FloatingActionButton));
  await tester.pump();

  expect(find.text('1'), findsOneWidget);
});
```

## Mocking Dependencies

### Creating Mock Services

Use packages like `mockito` or `mocktail` to create mocks:

```dart
import 'package:mocktail/mocktail.dart';

class MockAuthService extends Mock implements AuthService {}
class MockApiService extends Mock implements ApiService {}

testWidgets('LoginPage with mocked auth service', (tester) async {
  final mockAuth = MockAuthService();

  when(() => mockAuth.login(any(), any())).thenAnswer(
    (_) async => User(id: '1', name: 'Test User'),
  );

  await tester.pumpWidget(
    CompositionBuilder(
      setup: () {
        provide(mockAuth);

        return (context) => MaterialApp(home: LoginPage());
      },
    ),
  );

  // Enter credentials
  await tester.enterText(find.byType(TextField).first, 'test@example.com');
  await tester.enterText(find.byType(TextField).last, 'password');

  // Tap login
  await tester.tap(find.text('Login'));
  await tester.pumpAndSettle();

  // Verify login was called
  verify(() => mockAuth.login('test@example.com', 'password')).called(1);
});
```

### Providing Mock Dependencies

Inject mocks using `provide`:

```dart
testWidgets('Widget uses injected service', (tester) async {
  final mockUserRepo = MockUserRepository();

  when(() => mockUserRepo.getUser('1')).thenAnswer(
    (_) async => User(id: '1', name: 'Alice'),
  );

  await tester.pumpWidget(
    CompositionBuilder(
      setup: () {
        provide<UserRepository>(mockUserRepo);

        return (context) => MaterialApp(
          home: UserProfile(userId: '1'),
        );
      },
    ),
  );

  await tester.pumpAndSettle();

  expect(find.text('Alice'), findsOneWidget);
  verify(() => mockUserRepo.getUser('1')).called(1);
});
```

### Testing with InjectionKeys

Use InjectionKeys for type-safe mocking:

```dart
class UserRepositoryKey extends InjectionKey<UserRepository> {
  const UserRepositoryKey();
}

const userRepositoryKey = UserRepositoryKey();

testWidgets('Widget uses keyed dependency', (tester) async {
  final mockRepo = MockUserRepository();

  await tester.pumpWidget(
    CompositionBuilder(
      setup: () {
        provide<UserRepository>(mockRepo, key: userRepositoryKey);

        return (context) => MaterialApp(home: MyWidget());
      },
    ),
  );

  // Test continues...
});
```

## Testing Async Operations

### Testing useFuture

```dart
testWidgets('useFuture handles loading and success', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      home: CompositionBuilder(
        setup: () {
          final userData = useFuture(() async {
            await Future.delayed(Duration(milliseconds: 100));
            return User(name: 'Alice');
          });

          return (context) => switch (userData.value) {
            AsyncLoading() => CircularProgressIndicator(),
            AsyncData(:final value) => Text(value.name),
            AsyncError(:final errorValue) => Text('Error: $errorValue'),
            AsyncIdle() => SizedBox.shrink(),
          };
        },
      ),
    ),
  );

  // Initially loading
  expect(find.byType(CircularProgressIndicator), findsOneWidget);

  // Wait for future to complete
  await tester.pumpAndSettle();

  // Shows data
  expect(find.text('Alice'), findsOneWidget);
  expect(find.byType(CircularProgressIndicator), findsNothing);
});
```

### Testing useAsyncData

```dart
testWidgets('useAsyncData with watch refetches', (tester) async {
  final mockApi = MockApiService();
  const apiKey = InjectionKey<MockApiService>('mockApi');

  when(() => mockApi.fetchUser(1)).thenAnswer(
    (_) async => User(id: '1', name: 'Alice'),
  );
  when(() => mockApi.fetchUser(2)).thenAnswer(
    (_) async => User(id: '2', name: 'Bob'),
  );

  await tester.pumpWidget(
    CompositionBuilder(
      setup: () {
        provide(apiKey, mockApi);

        final userId = ref(1);
        final api = inject(apiKey);

        final (status, refresh) = useAsyncData<User, int>(
          (id) => api.fetchUser(id),
          watch: () => userId.value,
        );

        return (context) => Scaffold(
          body: switch (status.value) {
            AsyncData(:final value) => Text(value.name),
            _ => CircularProgressIndicator(),
          },
          floatingActionButton: FloatingActionButton(
            onPressed: () => userId.value = 2,
            child: Icon(Icons.next_plan),
          ),
        );
      },
    ),
  );

  await tester.pumpAndSettle();
  expect(find.text('Alice'), findsOneWidget);

  // Change userId - should refetch
  await tester.tap(find.byType(FloatingActionButton));
  await tester.pump();

  // Loading state
  expect(find.byType(CircularProgressIndicator), findsOneWidget);

  await tester.pumpAndSettle();

  // New data
  expect(find.text('Bob'), findsOneWidget);
  verify(() => mockApi.fetchUser(1)).called(1);
  verify(() => mockApi.fetchUser(2)).called(1);
});
```

### Testing Error States

```dart
testWidgets('Shows error state on failure', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      home: CompositionBuilder(
        setup: () {
          final userData = useFuture(() async {
            await Future.delayed(Duration(milliseconds: 100));
            throw Exception('Network error');
          });

          return (context) => switch (userData.value) {
            AsyncError(:final errorValue) => Text('Error: $errorValue'),
            AsyncLoading() => CircularProgressIndicator(),
            _ => SizedBox.shrink(),
          };
        },
      ),
    ),
  );

  await tester.pumpAndSettle();

  expect(find.textContaining('Network error'), findsOneWidget);
});
```

## Testing Patterns

### Testing Form Validation

```dart
testWidgets('Form validates input', (tester) async {
  await tester.pumpWidget(
    MaterialApp(home: LoginForm()),
  );

  // Submit with empty fields
  await tester.tap(find.text('Submit'));
  await tester.pump();

  expect(find.text('Email is required'), findsOneWidget);
  expect(find.text('Password is required'), findsOneWidget);

  // Enter invalid email
  await tester.enterText(find.byKey(Key('email')), 'invalid');
  await tester.tap(find.text('Submit'));
  await tester.pump();

  expect(find.text('Invalid email'), findsOneWidget);

  // Enter valid data
  await tester.enterText(find.byKey(Key('email')), 'test@example.com');
  await tester.enterText(find.byKey(Key('password')), 'password123');
  await tester.tap(find.text('Submit'));
  await tester.pump();

  // No errors
  expect(find.text('Email is required'), findsNothing);
  expect(find.text('Invalid email'), findsNothing);
});
```

### Testing Lifecycle Hooks

```dart
testWidgets('onMounted callback executes', (tester) async {
  var mountedCalled = false;

  await tester.pumpWidget(
    MaterialApp(
      home: CompositionBuilder(
        setup: () {
          onMounted(() {
            mountedCalled = true;
          });

          return (context) => Container();
        },
      ),
    ),
  );

  await tester.pumpAndSettle();

  expect(mountedCalled, true);
});

testWidgets('onUnmounted callback executes', (tester) async {
  var unmountedCalled = false;

  await tester.pumpWidget(
    MaterialApp(
      home: CompositionBuilder(
        setup: () {
          onUnmounted(() {
            unmountedCalled = true;
          });

          return (context) => Container();
        },
      ),
    ),
  );

  // Remove widget
  await tester.pumpWidget(SizedBox.shrink());
  await tester.pump();

  expect(unmountedCalled, true);
});
```

### Testing Controllers

```dart
testWidgets('ScrollController tracks position', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      home: CompositionBuilder(
        setup: () {
          final scrollController = useScrollController();
          final offset = ref(0.0);

          watchEffect(() {
            offset.value = scrollController.value.offset;
          });

          return (context) => Column(
            children: [
              Text('Offset: ${offset.value.toInt()}'),
              Expanded(
                child: ListView.builder(
                  controller: scrollController.raw, // .raw avoids unnecessary rebuilds
                  itemCount: 100,
                  itemBuilder: (context, index) => ListTile(
                    title: Text('Item $index'),
                  ),
                ),
              ),
            ],
          );
        },
      ),
    ),
  );

  expect(find.text('Offset: 0'), findsOneWidget);

  // Scroll down
  await tester.drag(find.byType(ListView), Offset(0, -500));
  await tester.pumpAndSettle();

  // Offset should have changed
  expect(find.textContaining('Offset: 0'), findsNothing);
});
```

## Best Practices

### 1. Test Behavior, Not Implementation

```dart
// ✅ Good - Tests observable behavior
testWidgets('Shows user name after loading', (tester) async {
  // Setup and assertions
});

// ❌ Bad - Tests internal implementation
testWidgets('Creates ref with null initial value', (tester) async {
  // Don't test internal details
});
```

### 2. Use Descriptive Test Names

```dart
// ✅ Good - Clear what is being tested
test('should increment counter when increment is called')
test('should show error message when login fails')
test('should disable submit button when form is invalid')

// ❌ Bad - Unclear purpose
test('test1')
test('button test')
test('works correctly')
```

### 3. Arrange-Act-Assert Pattern

```dart
test('should add item to cart', () {
  // Arrange
  final cart = CartStore();
  final product = Product(id: '1', name: 'Test', price: 10.0);

  // Act
  cart.addItem(product);

  // Assert
  expect(cart.items.value.length, 1);
  expect(cart.total.value, 10.0);
});
```

### 4. Mock External Dependencies

```dart
// ✅ Good - Mocks API calls
testWidgets('Shows loading then data', (tester) async {
  final mockApi = MockApiService();
  when(() => mockApi.fetchData()).thenAnswer(
    (_) async => Data(value: 'test'),
  );

  // Test with mock
});

// ❌ Bad - Makes real API calls
testWidgets('Fetches real data', (tester) async {
  // Don't make real network calls in tests
});
```

### 5. Test Edge Cases

```dart
group('useValidation', () {
  test('should handle empty input', () { /* ... */ });
  test('should handle whitespace', () { /* ... */ });
  test('should handle very long input', () { /* ... */ });
  test('should handle special characters', () { /* ... */ });
  test('should handle null values', () { /* ... */ });
});
```

### 6. Clean Up After Tests

```dart
testWidgets('Cleans up resources', (tester) async {
  final subscription = stream.listen((_) {});

  addTearDown(() {
    subscription.cancel();
  });

  // Test code
});
```

### 7. Use Test Groups

```dart
void main() {
  group('AuthService', () {
    late AuthService authService;

    setUp(() {
      authService = AuthService();
    });

    group('login', () {
      test('should succeed with valid credentials', () { /* ... */ });
      test('should fail with invalid credentials', () { /* ... */ });
      test('should update authentication state', () { /* ... */ });
    });

    group('logout', () {
      test('should clear user data', () { /* ... */ });
      test('should update authentication state', () { /* ... */ });
    });
  });
}
```

## Testing Checklist

Use this checklist for comprehensive testing:

### Unit Tests (Composables)
- [ ] Test initial state
- [ ] Test state updates
- [ ] Test computed values
- [ ] Test watch callbacks
- [ ] Test cleanup (onUnmounted)
- [ ] Test edge cases

### Widget Tests
- [ ] Test initial render
- [ ] Test user interactions
- [ ] Test prop changes
- [ ] Test reactive updates
- [ ] Test error states
- [ ] Test loading states

### Integration Tests
- [ ] Test complete user flows
- [ ] Test navigation
- [ ] Test data persistence
- [ ] Test dependency injection
- [ ] Test async operations

### Mocking
- [ ] Mock external services
- [ ] Mock API calls
- [ ] Mock storage
- [ ] Verify method calls
- [ ] Test error scenarios

## See Also

- [Best Practices](../guide/best-practices.md) — general best practices
- [Built-in Composables](../guide/built-in-composables.md) — catalog of built-in helpers
- [Dependency Injection](../guide/dependency-injection.md) — DI patterns
- [Creating Composables](../guide/creating-composables.md) — creating testable composables
